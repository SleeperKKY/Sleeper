//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clGyroTempDataListener.java
//  @ Date : 2015-07-30
//  @ Author : Kang Shin Wook
//
//

package org.androidtown.sleeper.endclasses;


//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clApp.java
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook, Kim Hyun Woong, Lim Hyun Woo
//  @ Email : rkdtlsdnr102@naver.com

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.Color;
import android.util.Log;

import com.jjoe64.graphview.DefaultLabelFormatter;
import com.jjoe64.graphview.GraphView;
import com.jjoe64.graphview.series.BarGraphSeries;
import com.jjoe64.graphview.series.DataPoint;
import com.jjoe64.graphview.series.LineGraphSeries;

import org.sleeper.propclasses.com_manager.clComManager ;
import org.sleeper.propclasses.com_manager.clRequestMessage;
import org.sleeper.propclasses.com_manager.clResponseMessage;
import org.sleeper.propclasses.dataprocessor_manager.clDataProcessor;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Sample class that implemented data processor and used its sleep stage output from sleep classifier to
 * control remote device.
 */
public class clAccelTempDataProcessor implements clDataProcessor.clSleepStageClassifier.ISleepStateListener, clComManager.IMessageListener, clDataProcessor.IDataProcessor {

	private clDatabaseManager myDatabase=null ;
	private Queue<Integer> SleepStateList = null ;
	private clComManager ComManager=null ;
    private Context AttachedContext=null ;

	private int prevCmd=-1 ;
    private int prevPwm=0 ;
    private int prevSleepState=0 ;
    private int noChangeCount=0 ;

    //used as output value of analyseWorsen
	private static final double BAD_TEMP=28;
   // private static final int HIGH_TEMPERATURE=0x00 ;
    private static final int HIGH_WINDPOWER=0x01 ;
    private static final int LOW_WINDPOWER=0x02 ;
    private static final int LITTLE_WORSEN_DEGREE =0x03 ;
    private static final int BIG_WORSEN_DEGREE =0x04 ;

    //used as output value of decideCommand
    private static final int WAITING =0x05 ;
    private static final int INCREASE_PWM=0x06 ;
    private static final int DECREASE_PWM=0x07 ;
    private static final int GOOD_SLEEP=0x08 ;
	private static final int INVALID=0x09 ;
	private static final int TURN_OFF=0x0A ;

    //pwm set
    private static final int LOW_PWM=64 ;
    private static final int MIDDLE_PWM=96 ;
    private static final int HIGH_PWM=127 ;
    private static final int[] PWM_SET={LOW_PWM,MIDDLE_PWM,HIGH_PWM} ;
    private int pwmIndex=0 ;

    //remote device command, public for test
    public static final byte TEMP_ID=0x10 ;
    public static final byte TEMP_MEASURE_TEMPERATURE=0x11 ;
    public static final byte FAN_ID=0x20 ;
    public static final byte FAN_SET_PWM=0x21 ;

	//public clDataManager many tables;
    private long startTime=0 ;//store current recent track's start time

    /**
     * Constructor
     * @param context attached application context
     */
	public clAccelTempDataProcessor(Context context){

        AttachedContext=context ;
		//SleepValueAvgList = new LinkedList<>() ;
		SleepStateList=new LinkedList() ;

		//set database
		myDatabase=new clDatabaseManager( AttachedContext) ;

		ComManager=new clComManager(this) ;
		ComManager.setTimeoutUnit(5000);
		ComManager.setTimeoutCount(2) ;

        clComManager.setPort(8090) ;

	}

    @Override
    public void onMeasureStart(clDataProcessor.clSleepStageClassifier SleepStageClassifier) {

        SleepStageClassifier.registerListener(this);
        //send command to arduino
        clRequestMessage reqMsg = new clRequestMessage();
        reqMsg.setDeviceID(FAN_ID);
        reqMsg.setCommand(FAN_SET_PWM) ;
        byte[] data={(byte)HIGH_PWM};
        reqMsg.setData(data) ;

        ComManager.connect() ;
        ComManager.send(reqMsg, true);

        //insert in database table
        Calendar calendar=Calendar.getInstance() ;
        SimpleDateFormat dateFormat=new SimpleDateFormat("yyyy-MM-dd") ;
        //put attributes in relation dataSummary
        ContentValues cv = new ContentValues() ;
        startTime=calendar.getTimeInMillis() ;//store store start time to use as primary key
        cv.put(clDatabaseManager.colDate, dateFormat.format(startTime)) ;
        cv.put(clDatabaseManager.colSleepTime, startTime) ;
        SQLiteDatabase db=myDatabase.getWritableDatabase() ;

        db.insert(clDatabaseManager.MBDTable,null,cv) ;//insert column

        db.close() ;
    }

    @Override
    public void onMeasureStop(clDataProcessor.clSleepStageClassifier SleepStageClassifier) {
        ComManager.disconnect() ;//disconnect com manager in case still connected to device
        SleepStageClassifier.unregisterListener(this);

        SQLiteDatabase db=myDatabase.getWritableDatabase();

        Calendar calendar=Calendar.getInstance() ;
        String[] columns={clDatabaseManager.colSleepTime} ;
        String where=clDatabaseManager.colSleepTime+"=?" ;
        String[] whereArgs={Long.toString(startTime)} ;
        //retrieve last summarydataTable's last row id
        Cursor cursor=db.query(clDatabaseManager.MBTTable,columns , where, whereArgs, null, null, null) ;

        if(cursor.getCount()==0)//if no data is inserted in MBT Table
        {
            db.delete(clDatabaseManager.MBDTable,where,whereArgs) ;
            Log.i("Data Result:","No Tuple") ;
        }
        else
        {
            ContentValues cv=new ContentValues() ;
            cv.put(clDatabaseManager.colWakeTime,calendar.getTimeInMillis()) ;
            db.update(clDatabaseManager.MBDTable, cv, where, whereArgs) ;

            Log.i("Data Result:", "Tuple exists") ;
        }
        cursor.close() ;

        db.close() ;
    }

    public clDatabaseManager getDatabaseManager(){

        return myDatabase ;
    }

    /**
     * Decide command for remote device
     * @param analysisResult
     * @return decided command: DECREASE_PWM, INCREASE_PWM,WAITING, GOOD_SLEEP
     */
	private int decideCommand(int analysisResult) {

        //decide command from analysis
        if(analysisResult==HIGH_WINDPOWER)
            return DECREASE_PWM ;
        else if(analysisResult==LOW_WINDPOWER)
            return INCREASE_PWM ;
        else if(analysisResult==GOOD_SLEEP)
            return TURN_OFF ;
        else if(analysisResult== WAITING)
            return WAITING;

		return INVALID ;
	}

    /**
     * Analyse sleep state change
     * @param currentSleepState current output from sleep state classifier
     * @param prevSleepState previous sleep state output from sleep state classifier
     * @param currentTemp current temperature retrieved from remote device
     * @param prevPwm previous pwm of fan
     * @return analysis result
     */
    private int analyseSleepStateChange(int currentSleepState,int prevSleepState, double currentTemp, int prevPwm){

        //insert decision value into data manager
        Log.i(toString(), "Decision Value calculated");

        int sleepStateChangeDegree = currentSleepState - prevSleepState ;
        int analysisResult=0 ;

        Log.i(toString(),"sleepStateChanged"+Integer.toString(sleepStateChangeDegree)) ;

        if(sleepStateChangeDegree>0){//if sleep state worsens

            if(currentSleepState == clDataProcessor.clSleepStageClassifier.AWAKE)//if current sleep state equals awake
            {
                analysisResult=analyseWorsen(BIG_WORSEN_DEGREE, prevPwm, currentTemp);
                Log.i("Sleep","sleep state worsened, changed to awake!!") ;
            }
            else if(currentSleepState == clDataProcessor.clSleepStageClassifier.REM){//if current sleep state equals

                analysisResult=analyseWorsen(LITTLE_WORSEN_DEGREE,prevPwm,currentTemp) ;
                Log.i("Sleep","sleep state worsened, changed to rem!!") ;
            }

            //set no change count to zero since change has happened
            noChangeCount=0 ;

            Log.i("Sleep","sleep state worsened!!") ;
        }
        else if(sleepStateChangeDegree==0)//if sleep state is same
        {
            if(++noChangeCount==2)//if thers no change in sleep state for 2 times
            {
                if (currentSleepState == clDataProcessor.clSleepStageClassifier.AWAKE)//if still awake
                {
                    analysisResult = analyseWorsen(BIG_WORSEN_DEGREE, prevPwm, currentTemp);
                    Log.i("Sleep", "sleep state worsened, still awake!!");
                }
                else if (currentSleepState == clDataProcessor.clSleepStageClassifier.REM)//if still rem
                {
                    analysisResult = analyseWorsen(LITTLE_WORSEN_DEGREE, prevPwm, currentTemp);
                    Log.i("Sleep", "sleep state worsened, still rem!!");
                }
                else if (currentSleepState == clDataProcessor.clSleepStageClassifier.DEEP)//if still deep, which means having good sleep
                {
                    analysisResult = GOOD_SLEEP;
                    Log.i("Sleep", "sleep state good sleep, good!!");
                }

                //set noChangeCount back to 0
                noChangeCount = 0;
            }
            else//waiting for previous command to be effective
            {
                analysisResult = WAITING;
                Log.i("Sleep","sleep state waiting!!") ;
            }
        }
        else{//if sleep improves

            //since it is in good sleep, we thought fan has to decrease power since high wind power
            //even low wind power will disrupt good sleeping
            analysisResult=HIGH_WINDPOWER ;

            //set no change count to zero since change has happened
            noChangeCount=0 ;

            Log.i("Sleep","sleep state no change!!") ;
        }

       return analysisResult ;
    }

    /**
     * Analyse possible cause for worsened sleep state
     * @param worsenDegree if worsen is high, input BIG_WORSEN, otherwise, input LITTLE_WORSEN
     * @param prevPwm previous pwm of fan
     * @param temp current temperature
     * @return cause of worsened sleep state: HIGH_WINDPOWER, LOW_WINDPOWER, WAITING
     */
    private int analyseWorsen(int worsenDegree, int prevPwm,double temp){

        int analysis=INVALID ;

        if(worsenDegree== BIG_WORSEN_DEGREE){

			Log.i("Analyze","BIG_WORSEN_DEGREE") ;

            if(prevPwm>=HIGH_PWM)//if pwm is too high
            {
				Log.i("Analyze","HIGH_WINDPOWER") ;
                //return HIGH_WINDPOWER ;
                analysis=HIGH_WINDPOWER ;
            }
            else if(prevPwm>=MIDDLE_PWM){//else if pwm is middle

                if(temp>=BAD_TEMP)//if temperature is high for good sleep
				{
					Log.i("Analyze","LOW_WINDPOWER") ;
					//return LOW_WINDPOWER;//cause is low wind power
                    analysis=LOW_WINDPOWER ;
				}
                else//if temperature is fit for good sleep
				{
					Log.i("Analyze","LOW_WINDPOWER") ;
					//return HIGH_WINDPOWER;//cause is high wind power
                    analysis=HIGH_WINDPOWER ;
				}
            }
            else{//if pwm is less than 50

			    Log.i("Analyze","LOW_WINDPOWER") ;
                //return LOW_WINDPOWER ;
                analysis=LOW_WINDPOWER ;
            }

        }
        else if(worsenDegree == LITTLE_WORSEN_DEGREE){

			Log.i("Analyze","LITTLE_WORSEN_DEGREE") ;

            if(prevPwm>=HIGH_PWM){

				Log.i("Analyze","HIGH_WINDPOWER") ;
                //return HIGH_WINDPOWER ;
                analysis=HIGH_WINDPOWER ;
            }
            else if(prevPwm>=MIDDLE_PWM){

				Log.i("Analyze","HIGH_WINDPOWER") ;
                //return HIGH_WINDPOWER ;
                analysis=HIGH_WINDPOWER ;
            }
            else {
				Log.i("Analyze","LOW_WINDPOWER") ;
				//return LOW_WINDPOWER;
                analysis=LOW_WINDPOWER ;
			}
        }

        return analysis;
    }


	@Override
	public void onSleepStateRetrievedEvent(int sleepState, final Double[] accelerometerValues) {

		//put code to do something after retrieving intensity values
        switch(sleepState){

            case clDataProcessor.clSleepStageClassifier.AWAKE:
                Log.i(toString(),"AWAKE") ;
                break ;
            case clDataProcessor.clSleepStageClassifier.DEEP:
                Log.i(toString(),"DEEP") ;
                break ;
            case clDataProcessor.clSleepStageClassifier.REM:
                Log.i(toString(),"REM") ;
                break ;
        }

		//add sleep state to list

		if(sleepState == clDataProcessor.clSleepStageClassifier.AWAKE ||
				sleepState== clDataProcessor.clSleepStageClassifier.REM ||
				sleepState== clDataProcessor.clSleepStageClassifier.DEEP) {

			SleepStateList.add(sleepState);

			//make temperature request message
			clRequestMessage reqMsg = new clRequestMessage();
			reqMsg.setDeviceID(TEMP_ID);
            reqMsg.setCommand(TEMP_MEASURE_TEMPERATURE) ;
			reqMsg.setData(null);

			ComManager.connect() ;
			ComManager.send(reqMsg,true);

		}

	}

    /**
     * Create statmanager object with given rowId of dataSummary table of clDataProcessor.clDatabaseManager
     * @return stat manager to draw graph
     */
	public clStatManager createStatManager(String[] MBDTableKey, String[] values) {

		clStatManager statManager=new clStatManager() ;

        SQLiteDatabase db=myDatabase.getWritableDatabase() ;
		//retrieve data from database
		//String[] colNames={clDatabaseManager.colTime, clDatabaseManager.colSleepLevel, clDatabaseManager.colTemp} ;
        //create where caluse
        String where=MBDTableKey[0]+"=?" ;

        if(MBDTableKey.length>1)
        {
            for(int i=1;i<MBDTableKey.length;i++)
            {
                where+="," ;
                where+=(MBDTableKey[i]+"=?") ;
            }
        }

        //query all data measured at certain start time
		Cursor mdtData=db.query(clDatabaseManager.MBTTable, null, where, values, null, null, null) ;
        //query measure start time from Measure-By-Day table
        String[] cols={clDatabaseManager.colSleepTime,clDatabaseManager.colWakeTime} ;

        //array of datapoints to be mapped into each series
		DataPoint[] sleepStateData=new DataPoint[mdtData.getCount()] ;
		DataPoint[] tempData=new DataPoint[mdtData.getCount()] ;
		double[] timeData=new double[mdtData.getCount()] ;

        long time ;
		int sleepState ;
		double tempVal ;

		int dataPointsIndex=0 ;

        //insert initial dumb data, to make datapoint[0]
        sleepStateData[dataPointsIndex]=new DataPoint(0,0) ;
        tempData[dataPointsIndex]=new DataPoint(0,0) ;
        timeData[dataPointsIndex]=0 ;
		//collect data x value and y value you want to draw and form datapoints
		while(mdtData.moveToNext()) {

			//get time, temperature, sleep level
			time=mdtData.getLong(mdtData.getColumnIndex(clDatabaseManager.colTime)) ;
			sleepState=mdtData.getInt(mdtData.getColumnIndex(clDatabaseManager.colSleepState));
			tempVal=mdtData.getInt(mdtData.getColumnIndex(clDatabaseManager.colTemp)) ;

			sleepStateData[dataPointsIndex]=new DataPoint(time,sleepState) ;
			tempData[dataPointsIndex]=new DataPoint(time,tempVal) ;
			timeData[dataPointsIndex]=time ;//time in milliseconds

			dataPointsIndex++ ;
		}

        mdtData.close() ;//close cursor

		//make graph
		GraphView graph=new GraphView(AttachedContext) ;

		LineGraphSeries<DataPoint> tempSeries=new LineGraphSeries(tempData) ;
		BarGraphSeries<DataPoint> sleepLevelSeries=new BarGraphSeries(sleepStateData) ;

		// style
		tempSeries.setColor(Color.rgb(255, 120, 120));

        //convert time data(x axis) to hourly type representation
        final SimpleDateFormat dateFormat=new SimpleDateFormat("HH") ;

		graph.getGridLabelRenderer().setLabelFormatter(new DefaultLabelFormatter() {

            @Override
            public String formatLabel(double value, boolean isValueX) {
                if (isValueX) {

                    return dateFormat.format(new Date((long) value));//millisecond to hour

                } else {
                    return super.formatLabel(value, isValueX);
                }
            }

        });

		//set additional information
		graph.getGridLabelRenderer().setNumHorizontalLabels(6); // only 6 because of the space
		graph.getGridLabelRenderer().setNumVerticalLabels(3);
		graph.getGridLabelRenderer().setHorizontalAxisTitle("Time");
		graph.getGridLabelRenderer().setVerticalAxisTitle("Sleep Level");
		graph.getGridLabelRenderer().setVerticalLabelsSecondScaleColor(Color.rgb(255, 120, 120));
		sleepLevelSeries.setTitle("SleepLevel");
		tempSeries.setTitle("Temp");
		graph.addSeries(sleepLevelSeries);
		graph.getSecondScale().addSeries(tempSeries) ;
		graph.setTitle("Sleep Level & Temp") ;

        //set length of graph
		statManager.addGraph(graph, sleepStateData.length) ;
		//set time data
		statManager.addXData(timeData) ;

        Cursor msTimeCursor=db.query(clDatabaseManager.MBDTable,cols,where,values,null,null,null) ;
        msTimeCursor.moveToFirst() ;//move measure time cursor to first

		SimpleDateFormat transFormat = new SimpleDateFormat("HH:mm");
		//add static data to be shown
		statManager.addStaticData("Sleep Time: ",
				transFormat.format(msTimeCursor.getLong(msTimeCursor.getColumnIndex(clDatabaseManager.colSleepTime))));
		statManager.addStaticData("Wake Time: ",
				transFormat.format(msTimeCursor.getLong(msTimeCursor.getColumnIndex(clDatabaseManager.colWakeTime)))) ;

        msTimeCursor.close() ;
        db.close() ;


		return statManager ;
	}

    /**
     * Do something after received response message from remote device
     * @param ResponseMessage response message received
     */
	@Override
	public void onReceiveMessageEvent(clResponseMessage ResponseMessage) {

		Log.i(toString(),"Device ID: "+ResponseMessage.getDeviceID()) ;

		//dissolve control info
		if(ResponseMessage.getDeviceID()== TEMP_ID)
		{
			int decidedCmd;
            int currentSleepState ;

			if(ResponseMessage.getCommand()== TEMP_MEASURE_TEMPERATURE &&
					ResponseMessage.getResponseType()== clResponseMessage.SUCCESS) {

				Log.i(toString(), "Temperature retrieved from remote device");
				Log.i(toString(), "Temperature retrieved: " + ResponseMessage.getData()[0]);

				Log.i(toString(), "params inserted");

                //get current sleep state
                currentSleepState=SleepStateList.poll() ;
				//calculate decision value
				//decidedCmd = decideCommand(currentSleepState,prevSleepState,tempMessageConverter.getData(),prevPwm) ;
                decidedCmd=decideCommand(analyseSleepStateChange(currentSleepState, prevSleepState,
                        ResponseMessage.getData()[0], prevPwm)) ;
                //update previous sleep state
                prevSleepState=currentSleepState ;

                SQLiteDatabase db=myDatabase.getWritableDatabase() ;

				//add column to datatable
				ContentValues cv=new ContentValues() ;

				cv.put(clDatabaseManager.colSleepTime,startTime) ;
                cv.put(clDatabaseManager.colTime,System.currentTimeMillis()) ;
				cv.put(clDatabaseManager.colSleepState,currentSleepState) ;
				cv.put(clDatabaseManager.colTemp,ResponseMessage.getData()[0]) ;
				cv.put(clDatabaseManager.colDecisionValue,decidedCmd) ;

				db.insert(clDatabaseManager.MBTTable, null, cv) ;

				Log.i(toString(), "Decided Command: "+Integer.toString(decidedCmd));

                if(decidedCmd!=WAITING && decidedCmd!=INVALID && //not if still waiting for effect or command invalid or
                        !(decidedCmd == prevCmd && prevCmd == TURN_OFF)) {//previous command was turn off and current command turn off

                    clRequestMessage reqMsg = new clRequestMessage();
                    byte[] data=null ;

                    if (decidedCmd == INCREASE_PWM)//if decided command is to increase pwm
                    {
                        //increase pwm until its highest pwm
                        if (pwmIndex < PWM_SET.length - 1)
							pwmIndex++ ;

                        //set pwm data on device message
                        data=new byte[1] ;
                        data[0]=(byte)PWM_SET[pwmIndex] ;

                        //update previous pwm
                        prevPwm = PWM_SET[pwmIndex];

                    } else if (decidedCmd == DECREASE_PWM)//if decided command is to decrease pwm
                    {
                        //decrease pwm until its lowest pwm
                        if (pwmIndex >= 1)
							pwmIndex-- ;

                        //set pwm data on device message
                        data=new byte[1] ;
                        data[0]=(byte)PWM_SET[pwmIndex] ;
                        //update previous pwm
                        prevPwm = PWM_SET[pwmIndex];

                    } else if (decidedCmd == TURN_OFF) {//if decided command is to turn off remote device

                        //set pwm data on device message
                        data=new byte[1] ;
                        data[0]=(byte)0 ;//set pwm 0
                        //update previous pwm
                        prevPwm = 0;
                    }

                    //send command to arduino
                    reqMsg.setData(data);
                    reqMsg.setDeviceID(FAN_ID);
                    reqMsg.setCommand(FAN_SET_PWM) ;

                    Log.i("Fan send","Sending to fan") ;

					ComManager.connect();
                    ComManager.send(reqMsg,true);

                }

                //store current command
                prevCmd=decidedCmd ;
			}
		}
		else if(ResponseMessage.getDeviceID()== FAN_ID){

            if(ResponseMessage.getCommand() == FAN_SET_PWM &&
                    ResponseMessage.getData()[0] == 0 &&
                    ResponseMessage.getResponseType()== clResponseMessage.SUCCESS){

                Log.i(toString(),"Fan turned off") ;
            }
			else if(ResponseMessage.getCommand()== FAN_SET_PWM &&
					ResponseMessage.getResponseType()== clResponseMessage.SUCCESS) {

				Log.i(toString(), "Fan pwm is set to "+(int)ResponseMessage.getData()[0]);
			}

		}

	}
}
