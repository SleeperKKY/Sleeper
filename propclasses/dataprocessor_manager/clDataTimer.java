//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clDataTimer
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook, Kim Hyun Woong, Kim Hyun Woo
//  @ Email : rkdtlsdnr102@naver.com


package org.androidtown.sleeper.propclasses.dataprocessor_manager;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clDataTimer.java
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook
//  @ Email : rkdtlsdnr102@naver.com

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.PowerManager;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

/**
 * Provides interface to synchronized timer tasks. This class uses one timer thread and every
 * listener is processed in that thread. It synchronize timer period with least-common-devisor period
 * between periods of listeners so users are recommended to have their listeners have common divisor
 * between their periods.
 */
public class clDataTimer {

	private List<IDataTimerListener> dataTimerListenerList ;
	private List<Long> dataTimerListenerPeriodList ;
	private long[] dataTimerListenerPeriodCheckList ;
	//private Context AttachedContext=null ;
	private boolean isRunning=false ;
    private long minimumRequiredPeriod ;


	private TimerTask RepeatTask ;
	private Timer RepeatTimer ;
	private int count=0 ;

	private AlarmReceiver alarmReceiver=null ;
    private PowerManager.WakeLock wakelock=null ;

	private Intent intent=null ;
	private PendingIntent pIntent=null ;
	private AlarmManager alarmManager=null ;
	private static String DATATIMER_ACTION_ALARM_REPEAT="DATATIMER_ACTION_ALARM_REPEAT" ;

	private boolean isRegistered=false ;

	private static clDataTimer instance=null ;

    /**
     * Constructor
     */
	private clDataTimer(){

		dataTimerListenerList=new ArrayList<>() ;
		dataTimerListenerPeriodList=new ArrayList<>() ;
		//AttachedContext=context ;
	}

    /**
     * Get instance
     * @return DataTimer instance
     */
	public static clDataTimer getInstance(){

		if(instance==null)
			instance=new clDataTimer() ;

		return instance ;
	}

	/**
	 * Register datatimer listener. Listener cannot be registered when timer is already running
	 * @param listener listener to register
	 * @param periodMillisec period of event to occur
	 * @return true if register succesful, otherwise false
	 */
	public boolean registerDataTimerListener(IDataTimerListener listener, long periodMillisec){

		if(!isRunning) {

			if(!dataTimerListenerList.contains(listener)) {
				dataTimerListenerList.add(listener);
				dataTimerListenerPeriodList.add(periodMillisec);
			}

			return true ;
		}

		return false ;

	}


    /**
     * Unregister listener
     * @param listener listener to unregister
     */
	public void unregisterDataTimerListener(IDataTimerListener listener){

		for(int i=0;i<dataTimerListenerList.size();i++)
		{
			if(listener.equals(dataTimerListenerList.get(i)))
			{
				dataTimerListenerList.remove(i) ;
				dataTimerListenerPeriodList.remove(i) ;
			}
		}
	}

    /**
     * Start timing task.
     */
	public void start() {

        long minimumRequiredPeriod=adjustPeriod();//adjust period

        Log.i("Minimum Required Period",Long.toString( minimumRequiredPeriod)+"ms") ;

		dataTimerListenerPeriodCheckList=new long[dataTimerListenerList.size()] ;


		RepeatTask = new TimerTask() {
			@Override
			public void run() {

                //Log.i(toString(), "dTimerListener Running");

                for (int i = 0; i < dataTimerListenerPeriodList.size(); i++) {
                    //check if current count matches certain listener's event time
                    if (dataTimerListenerPeriodList.get(i) == dataTimerListenerPeriodCheckList[i]) {
                        dataTimerListenerList.get(i).onEveryElapseEvent();
                        dataTimerListenerPeriodCheckList[i] = 1;
                    } else
                        dataTimerListenerPeriodCheckList[i]++;


                }

            }
        } ;


		//create timer
		RepeatTimer = new Timer();
		//start task
		RepeatTimer.schedule(RepeatTask, 0, minimumRequiredPeriod) ;


		//register repeating alarm receiver
/*
		if(!isRegistered) {
			IntentFilter filter=new IntentFilter(DATATIMER_ACTION_ALARM_REPEAT) ;
			alarmReceiver=new AlarmReceiver() ;
			AttachedContext.registerReceiver(alarmReceiver, filter);

			//create alarm receiver
			intent=new Intent(DATATIMER_ACTION_ALARM_REPEAT) ;
			pIntent=PendingIntent.getBroadcast(AttachedContext,0,intent,PendingIntent.FLAG_CANCEL_CURRENT) ;
			alarmManager=(AlarmManager)AttachedContext.getSystemService(Context.ALARM_SERVICE) ;
			alarmManager.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pIntent) ;

			isRegistered=true ;
		}
		*/

		isRunning=true ;
	}

    /**
     * Stop timing task.
     */
	public void stop() {

		//cancel measuring task
		RepeatTimer.cancel() ;

		//Log.i(toString(), "dTimerListener Stopped") ;


/*
		if(isRegistered) {
			alarmManager.cancel(pIntent);
			AttachedContext.unregisterReceiver(alarmReceiver);

			isRegistered=false ;
		}
*/
		isRunning=false ;

		dataTimerListenerPeriodCheckList=null ;

	}

    /**
     * Adjust period and returns least common devisor
     */
    private long adjustPeriod(){

        minimumRequiredPeriod=findMinimumRequiredPeriod() ;
        //maximumRequiredPeriod=minimumRequiredPeriod ;

        //change datatimer period list
        for(int i=0;i<dataTimerListenerPeriodList.size();i++){

            dataTimerListenerPeriodList.set(i,dataTimerListenerPeriodList.get(i)/minimumRequiredPeriod) ;
            //maximumRequiredPeriod*=dataTimerListenerPeriodList.get(i) ;
            Log.i("Listener Period: ",Long.toString(dataTimerListenerPeriodList.get(i))) ;
        }

        return minimumRequiredPeriod ;
    }

    /**
     * find minimum required period
     * @return minimum required period
     */
	private long findMinimumRequiredPeriod(){

		int size=dataTimerListenerPeriodList.size() ;

		if(size>1)
			return gcd(dataTimerListenerPeriodList.toArray(new Long[size])) ;
        else if(size==1)
            return dataTimerListenerPeriodList.get(0) ;
        else
            return 0 ;

	}

    /**
     * find great common devisor among elements in array
     */

	private long gcd(Long[] array){

        //sort array in ascending order
		Arrays.sort(array) ;

        //if value before last value is not 0, which means gcd has been found
		if(array[array.length-2]!=0){

            int index=0 ;
            long min=-1 ;

            //find minimum index of value which is minumum and not 0
            for(int i=0;i<array.length;i++){

                if(array[i]!=0 && (min==-1 || array[i]<min))
                {
                    min=array[i] ;
                    index=i ;
                }
            }

			for(int i=index+1;i<array.length;i++){
				array[i]%=array[index] ;
			}

			return gcd(array) ;
		}

		return array[array.length-1] ;
	}


	@Deprecated
	private class AlarmReceiver extends BroadcastReceiver {


		@Override
		public void onReceive(Context context, Intent intent) {

            //get wakelock
			/*
            PowerManager powerManager = (PowerManager) AttachedContext.getSystemService(Context.POWER_SERVICE);
            wakelock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                    "MyWakelockTag");
            wakelock.acquire() ;
            */

            if(intent.getAction().equals(DATATIMER_ACTION_ALARM_REPEAT)){

                Log.i("dtimer alarm", "repeat");
                // This is the Intent to deliver to our service.
                // Intent service = new Intent(context, AlarmService.class);

                //do stuff

                    for (int i = 0; i < dataTimerListenerPeriodList.size(); i++) {

                        //check if current count matches certain listener's event time
                        if (dataTimerListenerPeriodList.get(i) == dataTimerListenerPeriodCheckList[i]) {
                            dataTimerListenerList.get(i).onEveryElapseEvent();
                            dataTimerListenerPeriodCheckList[i] = 1;
                        } else
                            dataTimerListenerPeriodCheckList[i]++;

                    }
                    // Start the service, keeping the device awake while it is launching.
                    //startWakefulService(context,service) ;

                alarmManager.setExact(AlarmManager.RTC_WAKEUP,System.currentTimeMillis()+minimumRequiredPeriod,pIntent) ;
            }

            //wakelock.release() ;

		}
	}

	public interface IDataTimerListener {
        void onEveryElapseEvent();
    }
}
