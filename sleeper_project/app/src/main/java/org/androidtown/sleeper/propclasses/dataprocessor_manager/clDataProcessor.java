//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clDataProcessor, clDataProcessor.clSleepStateClassifier, clDataProcessor.clDatabaseManager
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook, Kim Hyun Woong, Kim Hyun Woo
//  @ Email : rkdtlsdnr102@naver.com


package org.androidtown.sleeper.propclasses.dataprocessor_manager;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clDataProcessor.java
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook
//  @ Email : rkdtlsdnr102@naver.com

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;

import org.androidtown.sleeper.propclasses.com_manager.clComManager;
import org.jtransforms.fft.DoubleFFT_1D;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Abstract processor that classifies sleep stage. User can implement this class to make their
 * sleep controlling equation and device controlling using sleep stage output from stage classifier.
 *
 */
public abstract class clDataProcessor implements clComManager.IMessageListener {

    private clDataTimer DataTimer=null ;
    protected Context AttachedContext=null ;
    private boolean isRunning=false ;
    private clSleepStageClassifier sleepClassifier =null ;
    private clDatabaseManager Database=null ;

    /**
     * Constructor
     * @param context context of this app
     */
    protected clDataProcessor(Context context){

        DataTimer=clDataTimer.getInstance() ;
        //create sleep state classifier
        sleepClassifier =new clSleepStageClassifier(context) ;
        AttachedContext=context ;

        Database=new clDatabaseManager(AttachedContext)  ;
    }

    /**
     * Start sleep tracking
     */
    public void measureStart(){

        isRunning=true ;

        SimpleDateFormat dateFormat = new SimpleDateFormat("yy-MM-dd");

        //put attributes in relation dataSummary
        ContentValues cv = new ContentValues() ;
        cv.put(clDatabaseManager.colDate,dateFormat.format(System.currentTimeMillis()));
        cv.put(clDatabaseManager.colStartTime, System.currentTimeMillis()) ;
        cv.put(clDatabaseManager.colEndTime,0) ;

        Database.insertSummaryTable(cv);

        //call attach function in sleep classifier
        sleepClassifier.attach();
        DataTimer.start() ;

    }

    /**
     * Stop sleep tracking
     */
    public void measureStop(){

        DataTimer.stop() ;
        sleepClassifier.detach() ;
        isRunning=false ;

        int lastRowId ;

        SQLiteDatabase db=Database.getWritableDatabase();

        //retrieve last summarydataTable's last row id
        String[] colId={clDatabaseManager.colCnt} ;
        Cursor cursor=db.query(clDatabaseManager.summarydataTable, colId, null, null, null, null, null) ;
        cursor.moveToLast() ;

        lastRowId=cursor.getInt(cursor.getColumnIndex(clDatabaseManager.colCnt)) ;

        cursor.close() ;

        //retrieve starttime of row with last row id
        String[] colStartTime={clDatabaseManager.colStartTime} ;
        String where=clDatabaseManager.colCnt+" = ? " ;
        String[] whereArgs={Integer.toString(lastRowId)} ;
        cursor=db.query(clDatabaseManager.summarydataTable,colStartTime,where,whereArgs,null,null,null) ;
        //update end time to row of datatable_summary table that was added at the start of this measure
        cursor.moveToFirst() ;

        long startTime=cursor.getLong(cursor.getColumnIndex(clDatabaseManager.colStartTime)) ;
        long endTime=System.currentTimeMillis() ;


        cursor.close() ;

        //if tracked time is less than sleep state retrieve period, which means no data inserted
       if(endTime-startTime<=clSleepStageClassifier.SleepStateRetrievePeriod)
       {
           //Log.i("measureStop","delete") ;
           Database.deleteSummaryTable(lastRowId) ;

       }else {//else

           //Log.i("measureStop", "update end") ;
           ContentValues cv = new ContentValues();
           cv.put(clDatabaseManager.colEndTime, System.currentTimeMillis());

           Database.updateSummaryTable(cv, where, whereArgs);
       }

        db.close() ;
    }

    /**
     * Get data timer
     * @return data timer
     */
    protected final clDataTimer getDataTimer(){

        return DataTimer ;
    }

    /**
     * Get sleep stage classifier
     * @return sleep stage classifier
     */
   protected final clSleepStageClassifier getSleepStageClassifier(){

       return sleepClassifier;
   }

    /**
     * Create statmanager with given rowId when click in StatisticManage Fragment
     * @param rowId row id of clicked row of dataSummary table of clDataProcessor
     * @return stat manager to draw graph
     */
    public abstract clStatManager createStatManager(int rowId) ;

    /**
     * Get database manager
     * @return database manager
     */
    public clDatabaseManager getDatabase(){

        return Database ;
    }

    /**
     * Classifies sleep stage using accelerometer sensor
     * it uses libsvm-androidjni, JTransform library
     */
    public static class clSleepStageClassifier{
        private List<ISleepStateListener> sleepStateListnerList;
        private List<Double> intensityList;
        //intensity array to avoid being incremented while calculate

        //to remove sensor noise
        private static final double Intensity_dev_Thresh =4;
        //intensity retrieve preiod in micro second
        private static final int IntensityValueRetrievePeriod =50 ;
        private static final long SleepStateRetrievePeriod=60000 ;
        private static final long FFTFeatureSampleRetrievePeriod=2000 ;

        private static final String dirPath= Environment.getExternalStorageDirectory()+"/MeasureResult" ;
        private static final String finename="result.txt" ;
        private static final String svmFilePath=Environment.getExternalStorageDirectory()+"/SvmFile" ;
        private static final String svmModelFilename="model" ;
        private static final String svmlibName="svmLib" ;

        //calculate fft feature at every 2 second, sleeptype classify at every 1 minute
        private clDataTimer.IDataTimerListener ClassifySleepType=null ;

        private Context AttachedContext=null ;

        //fft feature containser
        private List<double[]> fftMagnitudeList;
        private double[] fft_stddiv;
        private double[] fft_max;
        private static final int FFTBinSize =5 ;

        //sleep state
        public static final int AWAKE = 2 ;
        public static final int REM = 1;
        public static final int DEEP = 0 ;

        private int resultSleepState=-1 ;

        //private int intensityList_offset=0 ;
        private SensorEventListener sensorEventListener=null ;

        //declare svm interface function
        // svm native

        // Load the native library
        static {
            System.loadLibrary(svmlibName);
        }

        // svm native, classification function
        private native int doClassificationNative(double values[][], int indices[][],
                                                  int isProb, String modelFile, int labels[], double probs[]);

        /**
         * Constructor
         * @param context context to attach
         */
        private clSleepStageClassifier(Context context) {

            AttachedContext=context ;
            sleepStateListnerList= new ArrayList<>() ;
        }

        /**
         * Performed at every one minute. Remove intensity values in epoch where statndard deviation of that epoch
         * is bigger than certain value C.
         * @param intensityArray intensity array to remove noise
         */
        private void removeSensorNoise(Double[] intensityArray) {

            double avg=0.0 ;
            double sum=0 ;
            double intensityValue=0 ;
            double intensityListSize=intensityArray.length ;
            //double std_deviation=0.0 ;

            for(int i=0;i<intensityListSize;i++)
            {
                intensityValue=intensityArray[i];

                sum+=intensityValue ;
            }

            avg=sum/intensityListSize ;

            //remove noise between intensities if deviation is higher than standard deviation
            for(int i=0;i<intensityListSize;i++)
            {
                if(Math.abs(intensityArray[i]-avg)> clSleepStageClassifier.Intensity_dev_Thresh)
                    intensityArray[i]=0.0 ;
            }

        }


        /**
         * calculate fast fourier transform
         * @return double type array that contains transformed data
         */
        private void calcFFT(double[] tofft){

            DoubleFFT_1D doubleFFT_1D=new DoubleFFT_1D(tofft.length) ;

            //perform fast fourier transform on intensity values
            doubleFFT_1D.realForward(tofft);

        }

        /**
         * calculated every 2 second
         *
         * @param intensityArray*/
        private void calcFFTFeature(Double[] intensityArray, int start, int end) {

            double[] tofft= new double[end-start] ;

            for(int i=start;i<end;i++)
            {
                tofft[i-start]=intensityArray[i] ;
            }

            calcFFT(tofft) ;

            double magnitude ;
            //int magnitudeArraySize = FFTBinSize ;
            double[] magnitudeArray=new double[FFTBinSize] ;
            int incrementBy=(int)Math.ceil((double)(end-start)/FFTBinSize) ;

            for(int i=0,k=0;i<FFTBinSize;i++,k+=incrementBy)
            {
                magnitude=Math.sqrt(Math.pow(tofft[k], 2) + Math.pow(tofft[k + 1], 2)) ;

                magnitudeArray[i]=magnitude ;
            }

            //add each magnitude array into fft magnitude list
            fftMagnitudeList.add(magnitudeArray) ;
        }

        /**
         * performed at every one minute.
         * calculate standard deviation and max of each coefficient of filtered fft which were retrieved at every 2 second.
         *
         * For example, if low-pass-filter threshold was 2.5Hz then it will have 0.1~2.4Hz frequency, which results in 24 coefficients.
         * It will be added to the list at every 2 second until it is 1 minute so there will be 30 samples for each coefficient.Finally Calculate standard deviation and max values of each coefficients at every 1 minute.
         **/
        private void estimateFFT_SIGMA_MAX() {

            double avg=0.0 ;
            double sum=0 ;
            double sumP2=0 ;
            double magnitude=0 ;
            int fftMagnitudeListSize=fftMagnitudeList.size() ;
            double std_deviation=0.0 ;
            double maxCoefficient=0 ;


            for(int i=0;i< FFTBinSize;i++) {

                //Log.i("fftMagnitudeListSize",Integer.toString(fftMagnitudeListSize)) ;

                for (int j = 0; j < fftMagnitudeListSize; j++) {


                    magnitude=fftMagnitudeList.get(j)[i] ;

                    sumP2 += Math.pow(magnitude, 2);
                    sum += magnitude;

                    //change if magnitude which bigger than current max is found
                    if (maxCoefficient < magnitude)
                        maxCoefficient = magnitude;

                }

                avg = sum / fftMagnitudeListSize;

                //calculate standard deviation
                std_deviation = Math.sqrt(sumP2 / fftMagnitudeListSize - Math.pow(avg, 2));

                fft_stddiv[i]=std_deviation ;
                fft_max[i]=maxCoefficient ;

                //set maxCoefficient,sumP2,sum to 0
                maxCoefficient=0 ;
                sumP2=0 ;
                sum=0 ;

            }
        }

        /**
         * Calculate fft frequency feature of intensity array.
         *
         * Deprecated since svm doesn't classify sleep stage well when this feature is practiced along
         * pim, intensity average. Maybe there is some mistake on how we extract this feature so we will
         * keep looking into it.
         * @param intensityArray intensity array to calculate fft feature.
         */
        private void estimateFFTFeature(Double[] intensityArray){

            int fftFrameSize=intensityArray.length/(int)(SleepStateRetrievePeriod/FFTFeatureSampleRetrievePeriod) ;
            int i=0 ;

            //coordinate intensity length, discard ramaning after dividing with fftFrameSize
            int fftLength=intensityArray.length-(intensityArray.length%fftFrameSize) ;



            //calculate each fft feature for fftFrameSize
            for(i=0;i<fftLength;i+=fftFrameSize)
            {
                calcFFTFeature(intensityArray, i, i + fftFrameSize);
            }

            //estimate fft sigma max feature
            estimateFFT_SIGMA_MAX();
        }

        /**
         * classify sleep state using fft, pim, zcm features
         * row of double array is 1 since features are input at a same time
         * @return
         */
        private int classify() {

            //int feature_value_length=FFTBinSize*2+1+1+1 ;//2 fft feature array: max, standard deviation , PIM 1, ZCM 1, IntensityAvg 1
            int feature_value_length=FFTBinSize*2 ;
            double[][] values=new double[1][feature_value_length] ;
            int[][] indices=new int[1][feature_value_length] ;
            int[] labels=new int[1] ;
            double[] probs = new double[4];
            int isProb = 0; // Not probability prediction

            for(int i=0;i<FFTBinSize*2;i+=2){

                values[0][i]=fft_stddiv[i/2] ;
                indices[0][(i)]=(i+1) ;
                values[0][(i+1)]=fft_max[i/2] ;
                indices[0][(i+1)]=(i+2) ;
            }

            doClassificationNative(values, indices, isProb, svmFilePath + "/" + svmModelFilename, labels, probs) ;

            return labels[0] ;
        }

        /**
         * attach data timer and accelerometer sensor
         */
        private void attach(){

            //set all settings
            set() ;


            //create classify timer listener. you can put extra preprocess function here
            //to add more feature to classify
            ClassifySleepType=new clDataTimer.IDataTimerListener() {

                @Override
                public void onEveryElapseEvent() {
                    //get values collected so far

                    final Double[] intensityArray = intensityList.toArray(new Double[intensityList.size()]);

                    //remove sensor noise
                    removeSensorNoise(intensityArray);

                    estimateFFTFeature(intensityArray);

                    resultSleepState=classify() ;
                    //classify sleep type from pim, zcm, fft feature

                    for (final ISleepStateListener listener : sleepStateListnerList) {

                        /**
                         * create new handler on main thread's message queue since it it should not
                         * delay timer task
                         */
                        new Handler(Looper.getMainLooper()).post(new Runnable() {

                            @Override
                            public void run() {

                                listener.onSleepStateRetrievedEvent(resultSleepState, intensityArray);
                            }
                        });
                    }

                    reset() ;
                }

            } ;

            //register sensor event

            SensorManager sManager=(SensorManager)AttachedContext.getSystemService(Context.SENSOR_SERVICE) ;
            Sensor sensor=sManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION) ;

            clDataTimer.getInstance().registerDataTimerListener(ClassifySleepType, SleepStateRetrievePeriod) ;

            //register accelerometer sensor listener
            sensorEventListener=new SensorEventListener() {

                @Override
                public void onSensorChanged(SensorEvent event) {

                    intensityList.add(Math.sqrt(
                            Math.pow(event.values[0], 2) +
                                    Math.pow(event.values[1], 2) +
                                    Math.pow(event.values[2], 2)
                    )) ;
                }

                @Override
                public void onAccuracyChanged(Sensor sensor, int accuracy) {

                }
            } ;

            sManager.registerListener(sensorEventListener, sensor, IntensityValueRetrievePeriod * 1000) ;
        }

        /**
         * Set settings
         */
        private void set(){

            intensityList= new CopyOnWriteArrayList<>() ;
            fftMagnitudeList=new ArrayList<>() ;

            //create SvmFile directory, svmFile
            fft_stddiv=new double[FFTBinSize] ;
            fft_max=new double[FFTBinSize] ;
        }

        /**
         * Detach this movement detector from data timer and other sensor
         */
        private void detach(){

            clDataTimer.getInstance().unregisterDataTimerListener(ClassifySleepType);

            SensorManager sManager=(SensorManager)AttachedContext.getSystemService(Context.SENSOR_SERVICE) ;
            sManager.unregisterListener(sensorEventListener);
            sensorEventListener=null ;

            //reset all settings
            reset() ;

        }

        /**
         * Reset all settings
         */
        private void reset(){

            intensityList.clear() ;
            fftMagnitudeList.clear() ;

            //set all properties in fft_stddiv, fft_max to zero
            Arrays.fill(fft_stddiv,0);
            Arrays.fill(fft_max, 0) ;
        }

        /**
         * Register to listen to sleep stage classification event.
         * @param sleepStateListener listener to listen classification event.
         */
        public void registerSleepStateListener(clSleepStageClassifier.ISleepStateListener sleepStateListener){

            if(!sleepStateListnerList.contains(sleepStateListener))
                sleepStateListnerList.add(sleepStateListener) ;
        }

        /**
         * Unregister from sleep stage classification event.
         * @param sleepStateListener listener that is registered.
         */
        public void unregisterSleepStateListener(clSleepStageClassifier.ISleepStateListener sleepStateListener){

            if(sleepStateListnerList.contains(sleepStateListener))
                sleepStateListnerList.remove(sleepStateListener) ;
        }

        /**
         * Sleep state listener interface
         */
        public interface ISleepStateListener {

            /**
             * Fired when sleep state is retrieved.
             * @param sleepState classified sleep stage
             * @param accelerometerValues accelerometer values array gathered for certain times.
             */
            void onSleepStateRetrievedEvent(int sleepState, Double[] accelerometerValues);
        }
    }

    /**
     * Database manager that wraps up SQLite db helper. It has dataSummary table. New row is added
     * to this table when measure start, measure stop. Its '_id' column is used by user to identify
     * each table which would be named 'table1' when row with id 1 is inserted in dataSummary table
     * when measure started.
     */
    public static class clDatabaseManager extends SQLiteOpenHelper {


        private static final String dbName="SleeperDB";
        public static final String summarydataTable ="DataTable_summary" ;//@@@
        public static final String colCnt ="_id";//@@@
        public static final String colDate ="Date";//@@@
        public static final String colStartTime ="StartTime";//@@@
        public static final String colEndTime="EndTime" ;//@@@

        private List<IDbChangeListener> listenerList=null ;
        private  int lastRowId;

        /**
         * Constructor
         * @param context context to attach
         */
        protected clDatabaseManager(Context context) {

            super(context, dbName, null, 1);

            listenerList=new ArrayList<>() ;
        }

        @Override
        public void onCreate(SQLiteDatabase db) {

            //create datatable_summary
            db.execSQL("CREATE TABLE " + summarydataTable + " (" + colCnt + " INTEGER PRIMARY KEY AUTOINCREMENT, " + //@@@
                    colDate + " TEXT, " + colStartTime + " INTEGER, " + colEndTime + " INTEGER " + ")"); //@@@
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

        }

        @Override
        public void onOpen(SQLiteDatabase db) {
            super.onOpen(db);

            initialize(db) ;
        }

        /**
         * Initialize database. It keeps track of summary data table.
         * @param db SQLite database object
         */
        private void initialize(SQLiteDatabase db){


            String query = "SELECT  * FROM " + clDatabaseManager.summarydataTable + " order by "+ clDatabaseManager.colCnt +" desc limit 1";
            Cursor cursor = db.rawQuery(query, null);

            if(cursor.moveToFirst())//if query fails, when there is no column made in dataTable_summary
            {
                lastRowId = cursor.getInt(0) ;
            }
            else
                lastRowId =0;
        }

        /**
         * Add main database listener
         * @param listener listener to add
         */
        public void addListener(IDbChangeListener listener){

            if(!listenerList.contains(listener)){

                listener.setDB(this) ;
                listenerList.add(listener) ;
            }
        }

        /**
         * Remove listener from main database
         * @param listener listener to remove
         */
        public void removeListener(IDbChangeListener listener){

            if(listenerList.contains(listener)){

                listenerList.remove(listener) ;
            }
        }

        public int getLastRowId(){

            return lastRowId ;
        }

        /**
         * Insert into Datatable_Summary table
         * @param cv content values to put in new row of datatable summary table
         */
        public void insertSummaryTable(ContentValues cv){

            SQLiteDatabase db=this.getWritableDatabase() ;

            lastRowId++ ;//increment count since count indicate current end row of table

            cv.put(colCnt, lastRowId) ;//put incremented count
            db.insert(clDatabaseManager.summarydataTable, null, cv) ;

            //increment count after inserting new row into datatable summary table

            for(IDbChangeListener listener : listenerList)
                listener.onInsertSummaryTable(lastRowId);

            db.close() ;
        }

        /**
         * Update summary table
         * @param cv content values
         * @param where where clause
         * @param whereArgs where arguments
         * @return number of rows affected from update query
         */
        public int updateSummaryTable(ContentValues cv, String where, String[] whereArgs) {

            int upColCnt ;

            SQLiteDatabase db=this.getWritableDatabase();

            upColCnt=db.update(clDatabaseManager.summarydataTable,cv,where,whereArgs) ;

            db.close() ;

            return upColCnt ;
        }

        /**
         * Delete one row by unique startTime
         * @param rowId id of row to delete
         */
        public void deleteSummaryTable(int rowId){

            SQLiteDatabase db=getWritableDatabase() ;

            String where=colCnt+"=?" ;
            String[] whereArgs={Long.toString(rowId)} ;

            db.delete(summarydataTable,where,whereArgs) ;

            //Log.i("To delete Row id", Integer.toString(rowId)) ;

            for(IDbChangeListener listener : listenerList)
                listener.onDeleteSummaryTable(rowId);
        }

        /**
         * Listener to main database change
         */
        public interface IDbChangeListener{

            void setDB(SQLiteOpenHelper db) ;

            /**
             * Event occurs when inserting new row into datatable_summary table. Inserting to dataSummary table
             * occurs when tracking starts. So user's database will implement this method to make their own database table
             * synchronize with dataSummary table.
             *
             * For example, every time sleep tracking mode starts, user have to create new table to store information
             * of that each tracking. So when this event is called, user can create table with number that is equal to
             * number of summary table's last inserted row, like your_table_name1 when row number 1 is newly added.
             * @param rowId row index that is newly added to datatable_summary table
             */
            void onInsertSummaryTable(int rowId) ;

            /**
             * Event occurs when deleting row. It is same as onInsertSummaryTable except it occurs when
             * deleting.
             * @param rowId row id that was deleted from dataSummary table
             */
            void onDeleteSummaryTable(int rowId) ;
        }

    }
}