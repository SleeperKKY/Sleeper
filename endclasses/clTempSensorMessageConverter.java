package org.androidtown.sleeper.endclasses;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clApp.java
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook, Lim Hyun Woo
//  @ Email : rkdtlsdnr102@naver.com
//
//
//    Copyright (C) 2015  Kang Shin Wook, Kim Hyun Woong, Im Hyun Woo 
//
// 
//   This program is free software; you can redistribute it and/or modify 
//   it under the terms of the GNU General Public License as published by 
//   the Free Software Foundation; either version 2 of the License, or 
//   (at your option) any later version. 
//
// 
//    This program is distributed in the hope that it will be useful, 
//    but WITHOUT ANY WARRANTY; without even the implied warranty of 
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
//    GNU General Public License for more details. 
//
//
//    You should have received a copy of the GNU General Public License along 
//    with this program; if not, write to the Free Software Foundation, Inc., 
//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 

import android.util.Log;

import org.androidtown.sleeper.propclasses.com_manager.clDeviceMessageConverter;

/**
 * Make and dissolve custom  message. This is example of how developer of SleeperDevice should
 * make message parser class using clComManager.clDeviceMessageConverter class.
 */
public class clTempSensorMessageConverter extends clDeviceMessageConverter {

	public static final byte TEMP_ID =0x10 ;
	public static final byte MEASURE_TEMPERATURE = 0x11 ;


	public clTempSensorMessageConverter(){

		//ID=clDeviceMessageConverter.TEMP ;
	}

	@Override
	public String makeDeviceMessage() {


		String ControlInfo="" ;

			switch (Command) {

				//currently no data is required to send to remote device
				case MEASURE_TEMPERATURE:
					ControlInfo += (char)MEASURE_TEMPERATURE;
					break;

			}

		return ControlInfo ;
	}


	@Override
	public void dissolveDeviceMessage(String _ControlInfo) {

		this.Command=(byte)(_ControlInfo.charAt(0)) ;
		this.data=(byte)(_ControlInfo.charAt(1)) ;


		/*
		HashMap<Character,Float> dataMap=new HashMap<Character,Float>() ;

		char dataType, charPos ;
		float dataValue;

		dataType=_ControlInfo.charAt(0) ;
		dataValue=_ControlInfo.charAt(1) ;

		Log.i(toString(), "DataType: "+dataType+" DataValue: "+dataValue) ;

		dataMap.put(dataType, dataValue) ;

		charPos=2 ;

		//if delimiter matches ControlInfo's delimiter

		if(_ControlInfo.length()>2) {
			while (_ControlInfo.charAt(charPos) == ' ') {

				charPos++;

				dataType = _ControlInfo.charAt(charPos);
				dataValue = _ControlInfo.charAt(charPos + 1);

				dataMap.put(dataType, dataValue);

				charPos += 2;
			}
		}

		return dataMap ;
		*/

	}

}


