//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clGyroTempDataListener.java
//  @ Date : 2015-07-30
//  @ Author : Kang Shin Wook
//
//

package org.androidtown.sleeper.endclasses;


//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clApp.java
//  @ Date : 2015-09-06
//  @ Author : Kang Shin Wook, Kim Hyun Woong, Lim Hyun Woo
//  @ Email : rkdtlsdnr102@naver.com

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Color;
import android.util.Log;

import com.jjoe64.graphview.DefaultLabelFormatter;
import com.jjoe64.graphview.GraphView;
import com.jjoe64.graphview.helper.DateAsXAxisLabelFormatter;
import com.jjoe64.graphview.series.BarGraphSeries;
import com.jjoe64.graphview.series.DataPoint;
import com.jjoe64.graphview.series.LineGraphSeries;

import org.androidtown.sleeper.propclasses.com_manager.clComManager;
import org.androidtown.sleeper.propclasses.com_manager.clRequestMessage;
import org.androidtown.sleeper.propclasses.com_manager.clResponseMessage;
import org.androidtown.sleeper.propclasses.dataprocessor_manager.clDataProcessor;
import org.androidtown.sleeper.propclasses.dataprocessor_manager.clStatManager;

import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Sample class that implemented data processor and used its sleep stage output from sleep classifier to
 * control remote device.
 */
public class clAccelTempDataProcessor extends clDataProcessor implements clDataProcessor.clSleepStageClassifier.ISleepStateListener {

	private clMyDatabaseManager myDatabase=null ;
	private Queue<Integer> SleepStateList = null ;
	private clComManager ComManager=null ;

	private int prevCmd=-1 ;
    private int prevPwm=0 ;
    private int prevSleepState=0 ;
    private int noChangeCount=0 ;

    //used as output value of analyseWorsen
	private static final double BAD_TEMP=28;
   // private static final int HIGH_TEMPERATURE=0x00 ;
    private static final int HIGH_WINDPOWER=0x01 ;
    private static final int LOW_WINDPOWER=0x02 ;
    private static final int LITTLE_WORSEN_DEGREE =0x03 ;
    private static final int BIG_WORSEN_DEGREE =0x04 ;

    //used as output value of decideCommand
    private static final int WAITING =0x05 ;
    private static final int INCREASE_PWM=0x06 ;
    private static final int DECREASE_PWM=0x07 ;
    private static final int GOOD_SLEEP=0x08 ;
	private static final int INVALID=0x09 ;
	private static final int TURN_OFF=0x0A ;

    //pwm set
    private static final int LOW_PWM=64 ;
    private static final int MIDDLE_PWM=96 ;
    private static final int HIGH_PWM=127 ;
    private static final int[] PWM_SET={LOW_PWM,MIDDLE_PWM,HIGH_PWM} ;
    private static int pwmIndex=0 ;

	//public clDataManager many tables;


	public clAccelTempDataProcessor(Context context, clComManager _ComManager){

		//must be called before doing anything
		super(context) ;

		//SleepValueAvgList = new LinkedList<>() ;
		SleepStateList=new LinkedList() ;

		//set database
		myDatabase=new clMyDatabaseManager() ;

		ComManager=_ComManager ;
		ComManager.setMessageListener(this);
		ComManager.setTimeoutUnit(5000);
		ComManager.setTimeoutCount(2) ;

        clComManager.setPort(2323) ;

		//set database of dataprocessor to use onInsertDataSummaryTable
		getDatabase().addListener(myDatabase);
	}

    /**
     * Register as sleep stage listener and start measuring.
     */
	@Override
	public void measureStart(){

		getSleepStageClassifier().registerSleepStateListener(this);

        //send initial fan pwm set command to turn on fan
        clFanMessageConverter fanMessageConverter=new clFanMessageConverter();
        fanMessageConverter.setData((byte)HIGH_PWM) ;
        fanMessageConverter.setCommand(clFanMessageConverter.PWM_SET);
        //send command to arduino
        clRequestMessage reqMsg = new clRequestMessage();
        reqMsg.setDeviceID(clFanMessageConverter.FAN_ID);
        reqMsg.setDeviceMessage(fanMessageConverter.makeDeviceMessage());

        ComManager.connect() ;
        ComManager.send(reqMsg,true);


		super.measureStart();
	}

    /**
     * Unregister as sleep stage listener and stop measuring.
     */
	@Override
	public void measureStop(){

		super.measureStop();

		ComManager.disconnect() ;//disconnect com manager in case still connected to device
		getSleepStageClassifier().unregisterSleepStateListener(this);
	}

    /**
     * Decide command for remote device
     * @param analysisResult
     * @return decided command: DECREASE_PWM, INCREASE_PWM,WAITING, GOOD_SLEEP
     */
	private int decideCommand(int analysisResult) {

        //decide command from analysis
        if(analysisResult==HIGH_WINDPOWER)
            return DECREASE_PWM ;
        else if(analysisResult==LOW_WINDPOWER)
            return INCREASE_PWM ;
        else if(analysisResult==GOOD_SLEEP)
            return TURN_OFF ;
        else if(analysisResult== WAITING)
            return WAITING;

		return INVALID ;
	}

    private int analyseSleepStateChange(int currentSleepState,int prevSleepState, double currentTemp, int prevPwm){

        //insert decision value into data manager
        Log.i(toString(), "Decision Value calculated");

        int sleepStateChangeDegree = currentSleepState - prevSleepState ;
        int analysisResult=0 ;

        Log.i(toString(),"sleepStateChanged"+Integer.toString(sleepStateChangeDegree)) ;

        if(sleepStateChangeDegree>0){//if sleep state worsens

            if(currentSleepState == clSleepStageClassifier.AWAKE)//if current sleep state equals awake
            {
                analysisResult=analyseWorsen(BIG_WORSEN_DEGREE, prevPwm, currentTemp);
                Log.i("Sleep","sleep state worsened, changed to awake!!") ;
            }
            else if(currentSleepState == clSleepStageClassifier.REM){//if current sleep state equals

                analysisResult=analyseWorsen(LITTLE_WORSEN_DEGREE,prevPwm,currentTemp) ;
                Log.i("Sleep","sleep state worsened, changed to rem!!") ;
            }

            //set no change count to zero since change has happened
            noChangeCount=0 ;

            Log.i("Sleep","sleep state worsened!!") ;
        }
        else if(sleepStateChangeDegree==0)//if sleep state is same
        {
            if(++noChangeCount==5)//if thers no change in sleep state for 2 times
            {
                if (currentSleepState == clSleepStageClassifier.AWAKE)//if still awake
                {
                    analysisResult = analyseWorsen(BIG_WORSEN_DEGREE, prevPwm, currentTemp);
                    Log.i("Sleep", "sleep state worsened, still awake!!");
                }
                else if (currentSleepState == clSleepStageClassifier.REM)//if still rem
                {
                    analysisResult = analyseWorsen(LITTLE_WORSEN_DEGREE, prevPwm, currentTemp);
                    Log.i("Sleep", "sleep state worsened, still rem!!");
                }
                else if (currentSleepState == clSleepStageClassifier.DEEP)//if still deep, which means having good sleep
                {
                    analysisResult = GOOD_SLEEP;
                    Log.i("Sleep", "sleep state good sleep, good!!");
                }

                //set noChangeCount back to 0
                noChangeCount = 0;
            }
            else//waiting for previous command to be effective
            {
                analysisResult = WAITING;
                Log.i("Sleep","sleep state waiting!!") ;
            }
        }
        else{//if sleep improves

            //since it is in good sleep, we thought fan has to decrease power since high wind power
            //even low wind power will disrupt good sleeping
            analysisResult=HIGH_WINDPOWER ;

            //set no change count to zero since change has happened
            noChangeCount=0 ;

            Log.i("Sleep","sleep state no change!!") ;
        }

       return analysisResult ;
    }

    /**
     * Analyse possible cause for worsened sleep state
     * @param worsenDegree if worsen is high, input BIG_WORSEN, otherwise, input LITTLE_WORSEN
     * @param prevPwm previous pwm of fan
     * @param temp current temperature
     * @return cause of worsened sleep state: HIGH_WINDPOWER, LOW_WINDPOWER, WAITING
     */

    private int analyseWorsen(int worsenDegree, int prevPwm,double temp){

        int analysis=INVALID ;

        if(worsenDegree== BIG_WORSEN_DEGREE){

			Log.i("Analyze","BIG_WORSEN_DEGREE") ;

            if(prevPwm>=HIGH_PWM)//if pwm is too high
            {
				Log.i("Analyze","HIGH_WINDPOWER") ;
                //return HIGH_WINDPOWER ;
                analysis=HIGH_WINDPOWER ;
            }
            else if(prevPwm>=MIDDLE_PWM){//else if pwm is middle

                if(temp>=BAD_TEMP)//if temperature is high for good sleep
				{
					Log.i("Analyze","LOW_WINDPOWER") ;
					//return LOW_WINDPOWER;//cause is low wind power
                    analysis=LOW_WINDPOWER ;
				}
                else//if temperature is fit for good sleep
				{
					Log.i("Analyze","LOW_WINDPOWER") ;
					//return HIGH_WINDPOWER;//cause is high wind power
                    analysis=HIGH_WINDPOWER ;
				}
            }
            else{//if pwm is less than 50

			    Log.i("Analyze","LOW_WINDPOWER") ;
                //return LOW_WINDPOWER ;
                analysis=LOW_WINDPOWER ;
            }

        }
        else if(worsenDegree == LITTLE_WORSEN_DEGREE){

			Log.i("Analyze","LITTLE_WORSEN_DEGREE") ;

            if(prevPwm>=HIGH_PWM){

				Log.i("Analyze","HIGH_WINDPOWER") ;
                //return HIGH_WINDPOWER ;
                analysis=HIGH_WINDPOWER ;
            }
            else if(prevPwm>=MIDDLE_PWM){

				Log.i("Analyze","HIGH_WINDPOWER") ;
                //return HIGH_WINDPOWER ;
                analysis=HIGH_WINDPOWER ;
            }
            else {
				Log.i("Analyze","LOW_WINDPOWER") ;
				//return LOW_WINDPOWER;
                analysis=LOW_WINDPOWER ;
			}
        }

        return analysis;
    }


	@Override
	public void onSleepStateRetrievedEvent(int sleepState, Double[] accelerometerValues) {

		//put code to do something after retrieving intensity values

        switch(sleepState){

            case clSleepStageClassifier.AWAKE:
                Log.i(toString(),"AWAKE") ;
                break ;
            case clSleepStageClassifier.DEEP:
                Log.i(toString(),"DEEP") ;
                break ;
            case clSleepStageClassifier.REM:
                Log.i(toString(),"REM") ;
                break ;
        }

		//add sleep state to list

		if(sleepState== clSleepStageClassifier.AWAKE ||
				sleepState== clSleepStageClassifier.REM ||
				sleepState== clSleepStageClassifier.DEEP) {

			SleepStateList.add(sleepState);

			//make temperature request message
			clTempSensorMessageConverter tempSensorMessageConverter = new clTempSensorMessageConverter();

			tempSensorMessageConverter.setCommand(clTempSensorMessageConverter.MEASURE_TEMPERATURE);

			clRequestMessage reqMsg = new clRequestMessage();
			reqMsg.setDeviceID(tempSensorMessageConverter.TEMP_ID);
			reqMsg.setDeviceMessage(tempSensorMessageConverter.makeDeviceMessage());

			ComManager.connect() ;
			ComManager.send(reqMsg,true);

		}
	}

    /**
     * Create statmanager at given row when click in StatisticManage Fragment
     * @param rowPos row position of clicked item in listview
     * @return stat manager to draw graph
     */
	@Override
	public clStatManager createStatManager(int rowPos) {

		clStatManager statManager=new clStatManager() ;

		//retrieve data from database
		String[] colNames={clMyDatabaseManager.colTime,clMyDatabaseManager.colSleepLevel,clMyDatabaseManager.colTemp} ;
		Cursor myCursor=myDatabase.selectTable(clMyDatabaseManager.dataTable+Integer.toString(rowPos), colNames, null, null) ;

		DataPoint[] sleepLevelData=new DataPoint[myCursor.getCount()] ;
		DataPoint[] tempData=new DataPoint[myCursor.getCount()] ;
		double[] timeData=new double[myCursor.getCount()] ;

		long time ;
		int sleepLevelVal ;
		double tempVal ;

		int dataPointsIndex=0 ;

		//search queries
		while(myCursor.moveToNext()) {

			//get time, temperature, sleep level
			time=myCursor.getLong(myCursor.getColumnIndex(clMyDatabaseManager.colTime)) ;
			sleepLevelVal=myCursor.getInt(myCursor.getColumnIndex(clMyDatabaseManager.colSleepLevel));
			tempVal=myCursor.getDouble(myCursor.getColumnIndex(clMyDatabaseManager.colTemp)) ;

			sleepLevelData[dataPointsIndex]=new DataPoint(time,sleepLevelVal) ;
			tempData[dataPointsIndex]=new DataPoint(time,tempVal) ;
			timeData[dataPointsIndex]=time ;

			dataPointsIndex++ ;
		}

		//make graph
		GraphView graph=new GraphView(AttachedContext) ;

		LineGraphSeries<DataPoint> tempSeries=new LineGraphSeries(tempData) ;
		BarGraphSeries<DataPoint> sleepLevelSeries=new BarGraphSeries(sleepLevelData) ;

		// style
		tempSeries.setColor(Color.rgb(255, 120, 120));

		// set date label formatter

		graph.getGridLabelRenderer().setLabelFormatter(new DefaultLabelFormatter() {

            @Override
            public String formatLabel(double value, boolean isValueX) {
                if (isValueX) {
                    SimpleDateFormat format = new SimpleDateFormat("HH");

                    Date date = new Date((long) value);
                    return format.format(date);
                } else {
                    return super.formatLabel(value, isValueX);
                }
            }

        });

		//set additional information
		graph.getGridLabelRenderer().setNumHorizontalLabels(6); // only 6 because of the space
		graph.getGridLabelRenderer().setNumVerticalLabels(3);
		graph.getGridLabelRenderer().setHorizontalAxisTitle("Time");
		graph.getGridLabelRenderer().setVerticalAxisTitle("Sleep Level");
		graph.getGridLabelRenderer().setVerticalLabelsSecondScaleColor(Color.rgb(255, 120, 120));
		sleepLevelSeries.setTitle("SleepLevel");
		tempSeries.setTitle("Temp");
		graph.addSeries(sleepLevelSeries);
		graph.getSecondScale().addSeries(tempSeries) ;
		graph.setTitle("Sleep Level & Temp") ;

        Log.i("Hello2",toString()) ;

        //set length of graph
		statManager.addGraph(graph,sleepLevelData.length) ;
		//set time data
		statManager.addXData(timeData) ;

		SimpleDateFormat transFormat = new SimpleDateFormat("HH:mm");
		//add static data to be shown
		statManager.addStaticData("Sleep Time: ",
				transFormat.format(new Date((long) sleepLevelData[0].getX())));
		statManager.addStaticData("Wake Time: ",
				transFormat.format(new Date((long) sleepLevelData[sleepLevelData.length - 1].getX()))) ;


		return statManager ;
	}

    /**
     * Do something after received response message from remote device
     * @param ResponseMessage response message received
     */
	@Override
	public void onReceiveMessageEvent(clResponseMessage ResponseMessage) {

		Log.i(toString(),"ControlInfo: "+ResponseMessage.getDeviceMessage()) ;

		Log.i(toString(),"Device ID: "+ResponseMessage.getDeviceID()) ;

		//dissolve control info
		if(ResponseMessage.getDeviceID()== clTempSensorMessageConverter.TEMP_ID)
		{
			clTempSensorMessageConverter tempMessageConverter=new clTempSensorMessageConverter() ;

			//dissolve control info to data
			tempMessageConverter.dissolveDeviceMessage(ResponseMessage.getDeviceMessage()); ;

			int decidedCmd;
            int currentSleepState ;

			if(tempMessageConverter.getCommand()== clTempSensorMessageConverter.MEASURE_TEMPERATURE &&
					ResponseMessage.getResponseType()== clResponseMessage.SUCCESS) {

				Log.i(toString(), "Temperature retrieved from remote device");
				Log.i(toString(), "Temperature retrieved: " + tempMessageConverter.getData());

				Log.i(toString(), "params inserted");

                //get current sleep state
                currentSleepState=SleepStateList.poll() ;
				//calculate decision value
				//decidedCmd = decideCommand(currentSleepState,prevSleepState,tempMessageConverter.getData(),prevPwm) ;
                decidedCmd=decideCommand(analyseSleepStateChange(currentSleepState,prevSleepState,
                        tempMessageConverter.getData(), prevPwm)) ;
                //update previous sleep state
                prevSleepState=currentSleepState ;

				//add column to datatable
				ContentValues cv=new ContentValues() ;

				cv.put(clMyDatabaseManager.colTime,System.currentTimeMillis()) ;
				cv.put(clMyDatabaseManager.colSleepLevel,currentSleepState) ;
				cv.put(clMyDatabaseManager.colTemp,(byte)tempMessageConverter.getData()) ;
				cv.put(clMyDatabaseManager.colDecisionValue,decidedCmd) ;

				myDatabase.insertTable(clMyDatabaseManager.dataTable, null, cv) ;

				Log.i(toString(), "Decided Command: "+Integer.toString(decidedCmd));

                clFanMessageConverter fanMessageConverter=new clFanMessageConverter() ;

                if(decidedCmd!=WAITING && decidedCmd!=INVALID && //not if still waiting for effect or command invalid or
                        !(decidedCmd == prevCmd && prevCmd == TURN_OFF)) {//previous command was turn off and current command turn off

                    if (decidedCmd == INCREASE_PWM)//if decided command is to increase pwm
                    {
                        //increase pwm until its highest pwm
                        if (pwmIndex < PWM_SET.length - 1)
							pwmIndex++ ;

                        //set pwm data on device message
						fanMessageConverter.setData((byte)(PWM_SET[pwmIndex]));
                        //update previous pwm
                        prevPwm = PWM_SET[pwmIndex];
                        fanMessageConverter.setCommand(clFanMessageConverter.PWM_SET);
                    } else if (decidedCmd == DECREASE_PWM)//if decided command is to decrease pwm
                    {
                        //decrease pwm until its lowest pwm
                        if (pwmIndex >= 1)
							pwmIndex-- ;

                        //set pwm data
						fanMessageConverter.setData((byte) (PWM_SET[pwmIndex]));
                        //update previous pwm
                        prevPwm = PWM_SET[pwmIndex];
                        fanMessageConverter.setCommand(clFanMessageConverter.PWM_SET);

                    } else if (decidedCmd == TURN_OFF) {//if decided command is to turn off remote device

                        //set pwm 0
						fanMessageConverter.setData((byte)0) ;
                        fanMessageConverter.setCommand(clFanMessageConverter.PWM_SET);
                        //update previous pwm
                        prevPwm = 0;
                    }

                    //send command to arduino
                    clRequestMessage reqMsg = new clRequestMessage();
                    reqMsg.setDeviceID(clFanMessageConverter.FAN_ID);
                    reqMsg.setDeviceMessage(fanMessageConverter.makeDeviceMessage());

                    Log.i("Fan send","Sending to fan") ;

					ComManager.connect() ;
                    ComManager.send(reqMsg,true);

                }

                //store current command
                prevCmd=decidedCmd ;
			}
		}
		else if(ResponseMessage.getDeviceID()== clFanMessageConverter.FAN_ID){

			clFanMessageConverter fanMessageConverter=new clFanMessageConverter() ;

			//dissolve control info to data
			fanMessageConverter.dissolveDeviceMessage(ResponseMessage.getDeviceMessage()) ;

			if(fanMessageConverter.getCommand()== clFanMessageConverter.PWM_SET &&
					ResponseMessage.getResponseType()== clResponseMessage.SUCCESS) {

				Log.i(toString(), "Fan pwm is set to "+(int)fanMessageConverter.getData());
			}
            else if(fanMessageConverter.getCommand() == clFanMessageConverter.PWM_SET &&
					fanMessageConverter.getData() == (byte)0 &&
                    ResponseMessage.getResponseType()== clResponseMessage.SUCCESS){

                Log.i(toString(),"Fan turned off") ;
            }
		}

	}

}
