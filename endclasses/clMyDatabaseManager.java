package org.androidtown.sleeper.endclasses;//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Sleeper
//  @ File Name : clMyDatabase.java
//  @ Date : 2015-08-13
//  @ Author : Kang Shin Wook, Kim Hyun Woong, Im Hyun Woo
//
//
//    Copyright (C) 2015  Kang Shin Wook, Kim Hyun Woong, Im Hyun Woo 
//
// 
//   This program is free software; you can redistribute it and/or modify 
//   it under the terms of the GNU General Public License as published by 
//   the Free Software Foundation; either version 2 of the License, or 
//   (at your option) any later version. 
//
// 
//    This program is distributed in the hope that it will be useful, 
//    but WITHOUT ANY WARRANTY; without even the implied warranty of 
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
//    GNU General Public License for more details. 
//
//
//    You should have received a copy of the GNU General Public License along 
//    with this program; if not, write to the Free Software Foundation, Inc., 
//    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 


import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import org.androidtown.sleeper.propclasses.dataprocessor_manager.clDataProcessor;

/**
 * User defined database manage class. It should not directly manipulate SQLiteDatabase object. All
 * user's database manage class should implement clDataProcessor.clDatabaseManager.IDbChangeListener
 * and get SQLiteDatabase object by overriding setDB method. And user defined database manager should
 * only manipulate update, insert, delete when
 */
public class clMyDatabaseManager implements clDataProcessor.clDatabaseManager.IDbChangeListener {

	//static final String separator="_" ;
	public static final String dataTable ="DataTable" ;
	public static final String colElapseCnt ="ElapseCnt";
	public static final String colTemp ="Temperature";
	public static final String colTime ="Time";
	public static final String colDecisionValue="DecisionValue" ;

	public static final String colSleepLevel ="SleepLevel";

	//public static final String viewEmps="ViewEmps";

	private SQLiteOpenHelper parentDBHelper=null ;


    /**
     * Get SQLiteOpenHelper of parent class. User should get db helper object from this method.
     * @param parentDBHelper parent class' db heleper
     */
	@Override
	public void setDB(SQLiteOpenHelper parentDBHelper) {

        this.parentDBHelper=parentDBHelper ;
	}

    /**
     * Insert into certain user's table
     * @param tableName table name to insert content values.
     * @param nullColHack
     * @param cv content values
     */
	public void insertTable(String tableName, String nullColHack, ContentValues cv) {

        parentDBHelper.getWritableDatabase().insert(tableName, nullColHack, cv) ;
	}

    /**
     * Select query on certain table.
     * @param tableName name of table to give select query
     * @param columnNames certain column names to pick
     * @param where where clause
     * @param whereArgs where alguments
     * @return cursor result of select query
     */
    public Cursor selectTable(String tableName, String[] columnNames, String where, String[] whereArgs){

        Cursor cur= parentDBHelper.getWritableDatabase().query(tableName, columnNames, where, whereArgs, null, null, null) ;

        return cur ;
    }

    /**
     * Called when insertion occurred on clDataProcessor.clDataManager's dataSummaryTable
     * If there's insertion on dataSummaryTable, it means new measurement is started. You
     * almost certainly create create new table of your own for this measurement session.
     * So you should create table here with given rowIndex of row to be inserted on
     * clDataProcessor.clDataManager's dataSummaryTable.
     * @param rowIndex row index of inserted row in dataSummaryTable.
     */
	@Override
	public void onInsertSummaryTable(int rowIndex)
	{

		//Log.i("Created Table Name's num",Integer.toString(rowIndex)) ;

        SQLiteDatabase db=parentDBHelper.getWritableDatabase() ;
		//create data table
        db.execSQL("CREATE TABLE " + dataTable + Integer.toString(rowIndex) + " (" + colElapseCnt + " INTEGER PRIMARY KEY AUTOINCREMENT, " +
                colTime + " INTEGER, " + colSleepLevel + " INTEGER, " + colTemp + " INTEGER, " +
                colDecisionValue + " INTEGER)") ;

        db.close() ;
	}

    /**
     * Called when 1 row deletion occurred on clDataProcessor.clDataManager's dataSummaryTable.
     * If there's deletion on dataSummaryTable, it measurement result of certain session is deleted.
     * You almost certainly  delete table of that measurement session. So you should delete table here
     * with given rowIndex of row to be deleted on clDataProcessor.clDataManager's dataSummaryTable.
     * @param rowIndex
     */
	@Override
	public void onDeleteSummaryTable(int rowIndex) {

        parentDBHelper.getWritableDatabase().execSQL("DROP TABLE IF EXISTS " + dataTable + Integer.toString(rowIndex)) ;

	}
}
