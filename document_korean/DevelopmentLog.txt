2015.06.29
 - 수면관리시스템 Feature & Requirement Analysis/미완성
 - Feature & Requirement Analysis를 이용한 Use Case Diagram 제작/미완성
 - 수면관리시스템 모듈 도출/미완성
 - 수면관리시스템 Use Case 제작/미완성
 
2015.06.30
 - Use Case 수정
 - Class Diagram 제작/미완성
 
2015.07.03
 - Use Case 수정
 - 현재 Use Case를 이용하여 Class Diagram 완성/완료

2015.07.04
 - Use Case 추가(라즈베리파이에서 Use Case, GUI를 위한 Use Case 필요)/미완료
 
 - 추가된 Use Case를 완성하고 Class Diagram 수정/미완료
 
 - Dry(Don't Repeat Yourself) 원리를 적용하여 Feature & Requirement Analysis 수정
 
 - 무조건 Design Pattern을 맹목적으로 적용하기 보다는 유연하게 상황에 맞게 변형시켜서 적용한다.
   컨트롤러를 앱 관리자로 이름을 변경시켰다. 따라서 책임도 달라졌다. 앱 관리자에서 알람을 관리한다.
   그리고 원래 앱 관리자를 데이터 처리 관리자로 변경시켰다. 하는 일이 앱에 관련된 일 보다는 데이터
   처리를 주로 담당했기 때문이다. 이로써 사실상 컨트롤러는 사라지고 컨트롤러와 앱의 일을 앱 관리자에서
   도맡아서 하며 데이터 처리부라는 모듈을 두어서 데이터의 처리만 담당했다. 따라서 객체지향 설계를 할 때에는
   어떤 하나의 패턴을 무조건 적용시키기 보다는 패턴의 하나의 특징이나 여러 패턴의 특징들을 조합하는것이 더 
   중요한 것 같다.
   
2015.07.05
 - 앱 관리자에서 이벤트를 받도록 한다. 이벤트 함수들은 모두 public, 이벤트 함수 내부에서 하는 내부 동작은 모두 private로 할당
 - 수면 데이터 측정 Use Case의 analysis 다이어그램 작성
 
2015.07.07
 - "데이터 저장, 추출" Use Case에 대한 시나리오를 만들고 Sequence Diagram을 작성한다.
 - "수면 데이터 측정" Use Case에 대한 시나리오를 완성시키고 Sequence Diagram을 수정한다.
 - 위의 과정을 거친 뒤 Class Diagram을 수정한다.
 
2015.07.08
 - 라즈베리파이에서 아두이노로 기기 변경
 - DataProcessor은 여러가지 형태가 있을 수 있다. 자이로 센서의 데이터를 받아서 처리하는 Gyro DataProcessor가 있을 수 있고
   오디오 데이터를 받아서 처리하는 Audio DataProcessor가 있을 수 있다. 따라서 센서의 종류에 따라 처리가 달라야 하므로 
   clDataProcessor을 추상 클래스로 만드는것을 고려해봐야 한다.
 - 수면 관리 시스템 분석 수정
 
20150.07.09
 - DataProcessor는 수면 상태값을 측정하고 장치의 동작을 결정하는 결정값들을 생성한다. 그러나 DataProcessor가 어떤 센서를 쓰느냐에 따라
   내부의 값을 생성하는 식이나 수면 산태값을 측정하는 식이 달라질 수 있다. 그러므로 DataProcessor을 아예 추상 클래스로 두고 이 클래스를
   상속받아 함수들을 오버라이딩하여 구현하는것이 후에 코드 수정이나 다른 개발자들이 다른 센서를 적용하는데에 쉬울 것이다. 대신 식은 논문을
   참고하여서 피드백 저장같은것은 반드시 필요하다 생각되어 데이터베이스는 추상 클래스에 포함하도록 만들었다.
   
2015.07.10
 - UseCase의 #1 수면데이터 측정에선 자는시간 설정 삭제-> Start버튼을 누르면 그때부터 측정 시작으로 바꾸고 기기 연결 메뉴도 보여주는식으로 바꿈.
 - UI 제작, 통신 메세지 형태/ 미완성
 - 만나는 일정 정함. 현웅이 형이랑 매일 1시~5시 UML 설계를
 - 다음에 만날 시간: 7월 22일 이후
 
2015.07.11
 - DataTimer, AlarmTimer을 모두 안드로이드의 시스템 객체인 AlarmManager로 변경하였다. 이 객체는 어플 내의 어느 객체에서나 가져올 수 있으므로 사실상
   하나의 타이머만 앱에 존재하여 여러 타이밍 이벤트를 등록할 수 있다. 수신은 BroadcastService 인터페이스의 OnReceive를 구현하면된다.
 - Class Diagram을 변경하였고 이제 Analysis Diagram을 변경하여야 한다.
 
2015.07.22
 - clComManager는 한번에 하나의 와이파이와 통신할 수 있다. 그러므로 하나의 장치만이 앱과 연결된다. 그러나 그 장치에는 다시 온도센서나 선?기와 같이 여러가지 장치들이 연결되어 있을 수 있다. 그러므로
   여러가지 부속장치들과 동시에 구별하여 작동시킬 수 있어야 한다. 그러므로 clComManager은 부속장치들을 리스트 형태로 가지고 있고, 각 부속장치들은 그 장치만의 고유 ID와 명령들을 상수로 가지고 있으며, 
   그 명령을 송신 가능한 메세지 형태로 바꾸는 작업, 부속장치를 구분하여 작동시키는 방법, 해당 부속장치에 대한 명령이 타당한지 구별하는 작업, 그리고 그 장치와 관련된 메세지를 간단하게 변형하는 작업을
   추가하였다. 이렇게 함으로써 추후에 새로운 부속장치들이 붙을경우 비교적 크기가 작은 클래스를 만들기만 하면 되므로 변형에 용이하다.
 - clDataProcessor의 목적은 타이머와 거의 같다. 단지 결정 데이터를 계산하기 위한 부수 작업을 처리하는데에 특화되어 있다. 예를 들어, 1분마다 결정 데이터를 계산한다든지, 1분 동안 주기적으로 어떤 데이터들을
   취득하는 작업들을 한다. 결정 데이터를 계산하기 위해 현재는 자이로 데이터만이 주기적으로 취득되었다. 그러나 나중에 다른 식을 적용하거나, 여러가지 식을 동시에 처리하게 될 경우도 있으므로 clDataProcessor는
   여러 식을 동시에 처리하도록 DataListener들을 리스트 형태로 가지고 있다. DataListener들은 IDataListener 인터페이스를 구현한다. 이 인터페이스에는 1분 내에 주기적으로 처리할 작업, 1분이 경과했을 때 처리할 작업을
   구현하도록 함수를 제공한다. 또한 모든 데이터 처리가 마쳤을 때의 이벤트인 OnEveryCalculateCompleteEvent를 가지므로써 모든 작업이 끝마쳤을때 작업을 처리한다. 이렇게 하면 개발자는 추후에 새로운 식을 추가하거나
   동시에 여러식을 처리하고자 할 때, DataListener 인터페이스를 구현하여 DataProcessor에 등록시키기만 하면 된다. 그리고 데이터베이스는 DataProcessor가 아닌 DataListener들이 알아서 관리하도록 한다. 왜냐하면 
   따로 데이터를 저장하지 않는 방법이 생길수도 있기 때문이다. 그러므로 데이터베이스의 추가는 개발자의 몫이다. 
   
2015.07.24   
 - SleepManageFragment의 UI를 만든다.
 - "수면 측정" Use Case를 위한 기본 기능을 구현한다.
 - 알람 매니저와 브로드캐스트 수신자를 이용하여 알람 매세지를 브로드캐스트 수신자로 받기

2015.07.29
 - fragment 안에 fragment를 넣으니 match_parent속성이 부모 fragment와 일치하지 않음
 - 모든 View의 ID는 viewtype+viewname으로 이루어져 있다. viewtype은 2음절일경우 첫번째 음절은 첫 알파벳만 사용하거나 발음대로 알파벳을 만든다.
   예를 들어 Button의 발음이 버튼이므로 btn으로 만들면된다. TextView도 txtView처럼 발음에 따라 만들 수 있다. viewType은 항상 소문자이다.
 - 클래스다이어그램에서 리스트로 저장되는 것들은 모두 ID속성을 가지고 있다.
 - 통신 스레드 때문에 순서대로 데이터가 받아지지 않는다. 그러면 현재 수면 타입과 온도데이터가 각각 독립적으로 취득되어지므로 수면타입과 온도데이터가
   매치가 안될 수 있다. 그러므로 두 데이터가 저장되어질 때 같은 시간에 저장되어지도록 같은 시간 값을 공유하여야 한다. 그러므로 데이터를 저장하기 전
   시간을 먼저 취득한 뒤 수면타입을 저장할 때 이 시간을 같이 데이터베이스에 저장하고, 스레드를 시작할 때 이 시간을 변수로 넘겨줘서 나중에 온도데이터를
   받아서 저장할 때 이 시간에 저장하도록 한다.

2015.07.31
 - 클래스들을 UI, Core, End, Abstract 패키지들로 나누어 담음
 - 수면 데이터 측정을 위한 클래스 테스트 완료
 
2015.08.01
 - 자이로스코프 센서를 이용하여 수면 데이터 측정 시나리오 테스트 완료
 
2015.08.02
 - ComManager가 오직 하나의 소켓만 가져야 한다. 그러므로 정적 변수로 소켓을 가지고 정적멤버함수로 소켓을 할당한다.
 
2015.08.03
 - 요구분석서 내용 추가: 장치 만드는 사람, 수면 프로토콜 개발자, App만드는 사람으로 개발자를 나누고 App 개발자가 장치와 수면 프로토콜을 가지고
						 App을 만들어 aar파일로 만들어 배포한다. 그러면 앱에서는 그 aar파일을 다운받아서 그 앱의 기능을 쓸 수 있다.
						 
 - aar파일을 만들고 그 파일에서 리플랙션을 통해 클래스를 불러온 뒤 써본다.
 
2015.08.06
 - clDataProcessor->clDataTimer, clDataListener->clDataProcessor로 변경
 - 송수신 시나리오 테스트->int가 char형으로 변형되지 않고 string으로 변형되는 문제 발생->int를 char형으로 강제 형변환 시켜야 할 것 같다.
 
2015.08.07~08.14
 - 데이터타입을 모두 char형으로 바꿔서 사용하여 메세지 분리, 재결합 해결(강신욱)
 - 참조할 자바 파일들을 묶어서 apk파일로 만들고 앱에서 그 파일내부의 클래스를 참조한다.(가장 나중에, 일단 성공)
 - 클래스 파일들을 jar형태로 묶어서 관리한다: App부, 장치부, DataProcessor부로 나뉜다. App부에는 clApp, clStatManager, clComManager, clDataProcessor가 jar1, 장치부.jar파일이 라이브러리로 포함되어져야한다.
   DataProcessor부에는 clDataTimer, clDataProcessor, clDataManager, clComManager가 jar1, 장치부.jar파일이 라이브러리로 포함되어져야한다. 장치부에는 clDeviceMessageConverter가 jar파일로 만들어져야한다.(가장 나중에)
 - endclass들을 하나의 apk파일로 만들어 에뮬레이터에 적재시킨 뒤 거기에 앱을 동작시킨다.(가장 나중에)
 - 와이파이를 연결하거나 연결된 상태에서 그 와이파이의 이름으로 현재 연결된 기기를 지원하는 apk파일들을 리스트로 보여준다.(가장 나중에)
 - StatManager와 DataManager를 완성시킨다. 그리고 수면측정모드를 완성시키고 통계창을 만든다.(강신욱, 김현웅), 아두이노를 이용해 선풍기를 조작한다.(임현우), 
   아두이노와 와이파이를 연결하고 소켓통신을 수행한다.(강신욱,임현우): (2015.08.10, 11, 12)
   - 수면 측정 모드 프로토타입 완성
 - 아두이노에 request, response메세지를 기계에 맞게 해석하고 만드는 코드를 구현한다(강신욱, 임현우). 오프라인으로 수면측정모드를 테스트하고 통계창으로부터
   데이터를 확인한다.(강신욱, 김현웅)(2015.08.13)
 
2015.08.16
 - 와이파이 기능 보류
 - 알람 기능 추가
 - SleepValue 반올림 기준 단위값: 0.1
 - clMyApp, clApp 부활
 - 자이로 센서가 아닌 가속도 센서, 식 수정 & 오류 
 - BackButton 구현
 해야할 일
  - 수면 레벨 값 구하는 식 보완 & 결정 값 생성 식 고안(강신욱, 김현웅)
  - 통계창 구현(김현웅)
  - 기기와 와이파이 통신 구현(강신욱, 임현우)
  - 통계창 버그 고치기(데이터 베이스가 생성되지 않고 실행시 통계창 열면 에러 발생)
  
2015.08.17
 - 데이터 베이스 입력 버그 수정(HH:MM:SS->HH:mm:ss)
 - BackButton 동작 추가
 - 통계창 일부 구현 및 확인
 - 통신 관리부 수정: 통신스레드 별도로 둠
 해야할 일
  - 기기와 와이파이 통신 구현(강신욱, 임현우)
  - 수면 레벨 값 구하는 식 보완 & 결정 값 생성 식 고안(강신욱, 김현웅)
  - 기기와의 수동 모드 지원
  - UI 수정 및 추가
  
2015.08.18
 - 데이터 처리부 수정: 20Hz로 데이터 샘플, SleepValue가져옴
 - 통계창 수정: 날짜리스트별로 보여주기, clStatManager 코드 수정
 해야할 일
  - DecisionValue를 구하는 식 구현
  - FeedbackValue 초기값 추가 & 학습 식 구현
  - 아두이노로 선풍기 PWM 제어
  - 기기와 와이파이 통신 구현
  
2015.08.21
 - 수면 상태 분류기 추가: classify 미구현, zcm 미구현
 - 데이터 타이머 수정: 여러개의 리스너 가능
 - clAccelTempProcessor 수정: 수면 상태 분류기에서 수면 상태를 이용하여 기기 동작
 해야할 일
  - pim,zcm,fft 특성값들을 측정하고 그것을 파일에 저장한다. 저장하는 형식은 다음과 같다.
    
	저장시간 Intensity PIM ZCM FFT_STDDIV1 FFT_MAX1 ... FFT_STDDIV23 FFT_MAX23
	
	00:32:41 0.1213 p(1) z(1) fft_stddiv1(1) fft_max1(1) ... fft_stddiv23(1) fft_max23(1)
					...
	HH:mm:ss intensity p(n) z(n) fft_stddiv1(n) fft_max1(n) ... fft_stddiv23(n) fft_max23(n)

2015.08.23
 - SVM테스트 완료
 - 수면상태분류기 디버그: 스레드 동기화문제, fft구현
 - 저장 파일 만들기 완료
 해야할 일
  - fft, ifft 계산 결과가 이상함. 2초마다 계산하라고 했는데도 calcFFTFeature에 들어오는 fft frame의 크기가 20hz*2=40개를 거뜬히 넘어섬
  - 학습된 데이터를 sdcard에 저장한 뒤 스마트폰에서 수면상태를 올바르게 가져오는지 확인한다.
  - 가속도값과 수면상태의 상관관계를 보여주는 통계를 보고 각 시간에 측정된 특성들에게 클래스(DEEP,REM,AWAKE)를 정하고
    train_set 파일을 만든 뒤 예제 svm을 통해 학습시킨다.
	
2015.08.25
 - SVM 분류기 합체 완료
 - 수면상태분류기 완성: Intensity Value Average+PIM
 해야할 일
  - 수면 상태 분류기 ConcurrentModificationException 해결: IntensityList의 동시 접근 문제
  - clStatManager과 통계창 연계하고 현재 소스와 통합
  - UI 깔끔하게 다듬기
  - 참조할 자바 파일들을 묶어서 apk파일로 만들고 앱에서 그 파일내부의 클래스를 참조한다.(가장 나중에, 일단 성공)
  - endclass들을 하나의 apk파일로 만들어 에뮬레이터에 적재시킨 뒤 거기에 앱을 동작시킨다.(가장 나중에)
  - 와이파이를 연결하거나 연결된 상태에서 그 와이파이의 이름으로 현재 연결된 기기를 지원하는 apk파일들을 리스트로 보여준다.(가장 나중에)
  - APK안에 Model 파일을 집어넣어서 쓸 수 있도록 한다.
  - 수면 상태 분류기로부터 수면 상태를 받아와서 유저의 데이터프로세서에서 식을 통해서 선풍기를 조종한다.
  
2015.08.27
 - ConcurrentModificationException 해결: CopyOnWriteList로 해결
 - 수면분류기의 zcm에 threshold를 두어 일정 변화 이상에서만 count하기
 - zcm특성 제거
 - UI 수정: ssid뜨게 하기, 알람 시간 보이기
 해야할 일
  - clStatManager과 통계창 연계하고 현재 소스와 통합, 통계창 버그발생: 데이터가 1분단위로 들어가서 측정을 1분 이하로 할 경우 "데이터 없음" 예외가 발생한다.
  - UI 깔끔하게 다듬기
  - 참조할 자바 파일들을 묶어서 apk파일로 만들고 앱에서 그 파일내부의 클래스를 참조한다.(가장 나중에, 일단 성공)
  - endclass들을 하나의 apk파일로 만들어 에뮬레이터에 적재시킨 뒤 거기에 앱을 동작시킨다.(가장 나중에)
  - 와이파이를 연결하거나 연결된 상태에서 그 와이파이의 이름으로 현재 연결된 기기를 지원하는 apk파일들을 리스트로 보여준다.(가장 나중에)
  - APK안에 Model 파일을 집어넣어서 쓸 수 있도록 한다.
  - 수면 상태 분류기로부터 수면 상태를 받아와서 유저의 데이터프로세서에서 식을 통해서 선풍기를 조종한다.
  - 냉방기 조종 식 구현
  
2015.08.28
 - ConcurrentModificationException 해결: synchronize를 이용하여 list에 락을 걸었다.
 - ZCM 보류
 - 냉방기 조종하는 식 구현 & 테스트
 해야할 일
 - - clStatManager과 통계창 연계하고 현재 소스와 통합, 통계창 버그발생: 데이터가 1분단위로 들어가서 측정을 1분 이하로 할 경우 "데이터 없음" 예외가 발생한다.
  - UI 깔끔하게 다듬기
  - 참조할 자바 파일들을 묶어서 apk파일로 만들고 앱에서 그 파일내부의 클래스를 참조한다.(가장 나중에, 일단 성공)
  - endclass들을 하나의 apk파일로 만들어 에뮬레이터에 적재시킨 뒤 거기에 앱을 동작시킨다.(가장 나중에)
  - 와이파이를 연결하거나 연결된 상태에서 그 와이파이의 이름으로 현재 연결된 기기를 지원하는 apk파일들을 리스트로 보여준다.(가장 나중에)
  - APK안에 Model 파일을 집어넣어서 쓸 수 있도록 한다.
  - 수면 상태 분류기로부터 수면 상태를 받아와서 유저의 데이터프로세서에서 식을 통해서 선풍기를 조종한다.
  
2015.08.29
 - 2개의 FFT도 추가로 측정
 - ZCM 보류
 - 데이터 타이머의 발열문제 약간 해결: 리스너들중 최소 주기로 타이머 반복주기 결정
 해야할 일
 - 2015.08.28 답습
 - 통계창에서 통계 삭제 기능 추가
 - 통계 창의 X축 라벨 변화
 - 통계창 ui 완성하기
 - clStatManager의 인터페이스를 정교하게 구현
 - ui가 여러 사이즈의 기기에 비교적 공통으로 지원될 수 있는 방법 고안
 - 자세한 주석 추가
 - 발표 ppt 및 자료 정리(~10/03)
 - 사전 교육 이수 수행(~10/03)
 
2015.08.31
 - '설정 탭' 구현중
 해야할 일
 - 2015.08.28 진행중
 
2015.09.03
 - '설정 탭' 구현중
  - 와이파이 브로드캐스트 받기
  - 리스트 뷰의 아이템을 하나만 고르기
  - Search 버튼을 누르면 'SleeperLib/custom-proc/'에 위치한 프로세서 파일들의 'explanation' 파일을 읽어서 
   현재 연결된 기기와 일치하는 기기를 찾으면 그 프로세서 파일의 이름을 리스트 뷰에 표시해준다.(최우선)
   
 해야할 일
 - 'clApp' 패키지, 'dataprocessor-manager' 패키지와 'comManager' 패키지를 'sleeper.jar'파일로 묶은 다음, 그 jar파일을 import하여 endclasses 패키지들을 다른곳에서 만들어서 다시 .jar파일을 만든다.
 그리고 실제 앱에서는 그 endclass들의 jar을 가지고 reflection을 통해 App안에 넣어준다. 그리고 원래 앱도 결국 'sleeper.jar'을 import하여 만들도록 한다.
 - 표시된 프로세서들 중 하나를 누르고 '확인' 버튼을 누르면 그 프로세서의 jar파일에서 그 프로세서의 이름으로된 
   class를 가져와서 App에 넣어준다.(최우선) 프로세서 폴더의 이름과 jar파일 이름과 프로세서 클래스의 이름은 모두 동일해야한다.(?수)
 - 리스트 뷰에 표시된 아이템을 누르면 다이얼로그를 이용하여 정보가 표시된다.(보류)
 
2015.09.06
 - 발열 문제 해결
 - Javadoc를 만듦
 - github를 이용하여 프로젝트를 공개
 
 해야할 일
  - UI 다듬기
  - 발표 자료 만들기
  - 동적으로 프로세서를 로딩하기(Dex클래스 로딩)(보류)
  
2015.09.07
 해야할 일
 - 통계창에서 1분 이상 측정되지 않은 데이터는 삭제해버린다.
 - 통계창에서 삭제버튼을 추가하여 필요없는 측정을 삭제한다.
 - 알람기능 추가하기
 
2015.09.09
 - 수면 상태를 가져온 다음 판단을 해서 선풍기 구동 완료
 해야할 일
 - UI 다듬기(중요)
  : 로고 변경하기
  : 배경색 바꾸기
 - 통계창에서 1분 이상 측정되지 않은 데이터는 삭제해버린다.(중요)
 - 알람기능 추가하기(안중요)
 - 자료 정리하기
  : 코드 주석 정리하기
  : JAVADOC를 정리하기
  : GITHUB의 Readme에 오픈소스에 대한 설명 넣기(중요)
   # clDataProcessor에 대한 설명
   # clDataTimer에 대한 설명
   # com_manager 패키지에 대한 설명
   # endclasses 패키지에 대한 설명
  : 요구 분석서 및 UML 자료 정리, 업데이트(중요)
  : 아두이노 코드 정리하기
  : 테스트 코드 정리
  : 실제 환경에서 테스트 해보기(7일정도) - 실험대상 미정
  
2015.09.10
 - 통계창에서 1분 이상 측정되지 않은 데이터는 삭제해버린다.(중요)
 - 통계창에서 삭제버튼을 추가하여 필요없는 측정을 삭제한다.
 해야할 일
 - UI 다듬기(중요)
  : 로고 변경하기
  : 배경색 바꾸기
 - 알람기능 추가하기(안중요)
 - 자료 정리하기
  : 코드 주석 정리하기
  : JAVADOC를 정리하기
  : GITHUB의 Readme에 오픈소스에 대한 설명 넣기(중요)
   # clDataProcessor에 대한 설명
   # clDataTimer에 대한 설명
   # com_manager 패키지에 대한 설명
   # endclasses 패키지에 대한 설명
  : 요구 분석서 및 UML 자료 정리, 업데이트(중요)
  : 아두이노 코드 정리하기
  : 테스트 코드 정리
  : 실제 환경에서 테스트 해보기(7일정도) - 실험대상 미정
  
2015.09.12
 - 자료 정리하기
  : JAVADOC 정리하기
  : GITHUB 정리
  : 요구 분석서 및 UML 자료 정리
 해야할 일
 - UI 다듬기(중요)
 - 로고 변경하기
 - 아두이노 코드 정리하기
 - 테스트 코드 정리
 - 실제 환경에서 테스트 해보기(7일정도) - 실험대상 미정